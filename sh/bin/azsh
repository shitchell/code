#!/usr/bin/env bash
#
# Run pipelines and view/download logs

include-source 'debug.sh'
include-source 'echo.sh'
include-source 'shell.sh'

## usage functions #############################################################
################################################################################

function help-usage() {
    echo "usage: $(basename $0) [-h] [--help] [-v] [-o <organization>] [-p <project>] [-r <repo>]"
}

function help-epilogue() {
    echo "Run pipelines and view/download logs"
}

function parse-args() {
    SUBCOMMAND="help"
    SUBCOMMAND_ARGS=()
    POSITIONAL_ARGS=()

    # Default values
    ORGANIZATION="${AZURE_ORGANIZATION}"
    PROJECT="${AZURE_PROJECT}"
    REPO="${AZURE_REPO}"
    TOKEN="${AZURE_PAT}"
    PASS_NAME="azure/pat/default"

    # Loop over the arguments
    while [[ ${#} -gt 0 ]]; do
        case ${1} in
            -h)
                help-usage
                help-epilogue
                exit 0
                ;;
            --help)
                help-full
                exit 0
                ;;
            -o | --organization)
                ORGANIZATION="${2}"
                shift 2
                ;;
            -p | --project)
                PROJECT="${2}"
                shift 2
                ;;
            -r | --repo)
                REPO="${2}"
                shift 2
                ;;
            -t | --token)
                TOKEN="${2}"
                shift 2
                ;;
            -P | --pass-name)
                PASS_NAME="${2}"
                shift 2
                ;;
            -v | --verbose)
                verbose=1
                shift 1
                ;;
            -*)
                echo-stderr "error: unknown option ${1}"
                echo-stderr "$(help-usage)"
                exit 1
                ;;
            *)
                # We've finally reached the subcommand! yay!
                SUBCOMMAND="${1}"
                shift 1
                SUBCOMMAND_ARGS=("${@}")
                break
                ;;
        esac
    done

    # We need a token, organization, and project (except for the help command)
    if [[ "${SUBCOMMAND}" != "help" ]]; then
        if [[ -z "${TOKEN}" ]]; then
            # Check if a `pass` token is available
            TOKEN=$(pass show "${PASS_NAME}")
            if [[ -z "${TOKEN}" ]]; then
                # No token available
                echo "error: token not set" >&2
                return 1
            fi
        elif [[ -z "${ORGANIZATION}" ]]; then
            echo "error: organization not set" >&2
            return 1
        elif [[ -z "${PROJECT}" ]]; then
            echo "error: project not set" >&2
            return 1
        fi
    fi

    # Generate url encoded versions of the organization, project, and repo
    ORGANIZATION_ENC="$(urlencode "${ORGANIZATION}")"
    PROJECT_ENC="$(urlencode "${PROJECT}")"
    REPO_ENC="$(urlencode "${REPO}")"

    # Debug infos
    debug "SUBCOMMAND: ${SUBCOMMAND}"
    debug "SUBCOMMAND_ARGS: $(printf "%q " "${SUBCOMMAND_ARGS[@]}")"
    debug "POSITIONAL_ARGS: $(printf "%q " "${POSITIONAL_ARGS[@]}")"
    debug "ORGANIZATION: ${ORGANIZATION}"
    debug "PROJECT: ${PROJECT}"
    debug "REPO: ${REPO}"
    debug "PASS_NAME: ${PASS_NAME}"
    debug "TOKEN: ${TOKEN}"
}

function help-full() {
    help-usage
    help-epilogue
}

## helpful functions ###########################################################
################################################################################

# URL encode the specified string
function urlencode() {
    local string="${1}"
    local data

    if [[ $# != 1 ]]; then
        echo "usage: urlencode <string>" >&2
        return 1
    fi

    data="$(curl -s -o /dev/null -w %{url_effective} --get --data-urlencode "${string}" "")"
    if [[ $? != 3 ]]; then
        echo "Unexpected error" 1>&2
        return 2
    fi

    echo "${data##/?}"
}

function json-escape() {
    local str="${1}"
    if [ -z "${str}" ]; then
        str=$(cat)
    fi
    echo "${str}" \
        | sed 's/"/\\"/g' \
        | sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/\\n/g' \
        | sed -e ':a' -e 'N' -e '$!ba' -e 's/\r/\\r/g' \
        | sed -e ':a' -e 'N' -e '$!ba' -e 's/\t/\\t/g'
}

# Convert an array with values in the format `key=value` to a JSON object
function key-value-array-to-json() {
    local values=("${@}")
    local json='{'
    for value in "${values[@]}"; do
        local key=$(echo "${value}" | cut -d '=' -f 1 | json-escape)
        local val=$(echo "${value}" | cut -d '=' -f 2- | json-escape)
        json="${json}\"${key}\":\"${val}\","
    done
    json="${json%,}}"
    echo "${json}"
}

## subcommands #################################################################
################################################################################

# @description Get a pipeline's ID
# @usage id <pipeline-name>
function _subcommand_id() {
    local pipeline_name="${1}"
    id=$(
        _subcommand_list \
            | sed -Ee 's/  +/\t/' \
            | grep -Po "^${pipeline_name}\t\K.*"
    )
    if [ -z "${id}" ]; then
        echo "Pipeline '${pipeline_name}' not found" >&2
        return 1
    fi
    echo "${id}"
}

# @description Get information about a pipeline run
# @usage run-info <pipeline> <run-id>
function _subcommand_run-info() {
    local run_id="${1}"

    # Ensure a pipeline and run_id were provided
    if [ -z "${run_id}" ]; then
        echo "error: run_id is required" >&2
        return 1
    fi

    # Get the pipeline run information
    local response=$(
        curl "https://dev.azure.com/${ORGANIZATION_ENC}/${PROJECT_ENC}/_apis/build/builds/${run_id}?api-version=5.1" \
            --silent \
            --user ":${TOKEN}" \
            | python -m json.tool
    )

    # Get the pipeline name
    local pipeline_name=$(echo "${response}" | grep -oP '(?<="name": ")[^"]+' | awk NR==1)
    # Get the run name
    local build_number=$(echo "${response}" | grep -oP '(?<="buildNumber": ")[^"]+' | awk NR==1)
    # Get the branch it was run on
    local branch_name=$(echo "${response}" | grep -oP '(?<="sourceBranch": ")[^"]+')
    # Get the requester
    local requestee_name=$(echo "${response}" | grep -oP '(?<="displayName": ")[^"]+' | awk NR==2)
    local requestee_email=$(echo "${response}" | grep -oP '(?<="uniqueName": ")[^"]+' | awk NR==2)
    # Get the created date
    local created_date=$(echo "${response}" | grep -oP '(?<="startTime": ")[^"]+')
    # Get the completed date
    local finished_date=$(echo "${response}" | grep -oP '(?<="finishTime": ")[^"]+')
    # Get the duration
    local duration=$(( $(date -d "${finished_date}" +%s) - $(date -d "${created_date}" +%s) ))
    # Convert the duration to human readable format
    duration=$(date -d@${duration} -u +%H:%M:%S)
    # Get the state
    local status=$(echo "${response}" | grep -oP '(?<="status": ")[^"]+')
    # Get the result
    local result=$(echo "${response}" | grep -oP '(?<="result": ")[^"]+')

    # Print the pipeline details
    echo "Pipeline:   ${pipeline_name}"
    echo "Run:        ${build_number}"
    echo "Branch:     ${branch_name}"
    echo "Requestee:  ${requestee_name} <${requestee_email}>"
    echo "Started:    $(date -d "${created_date}" '+%Y-%m-%d %H:%M:%S')"
    echo "Finished:   $(date -d "${finished_date}" '+%Y-%m-%d %H:%M:%S')"
    echo "Duration:   ${duration}"
    echo "Status:     ${status}"
    echo "Result:     ${result}"
}

# Wait for a pipeline to complete
# @description Wait for a pipeline to complete
# @usage wait [-t|--timeout <seconds>] [-q|--quiet] <run id>
function _subcommand_wait() {
    # Parse the arguments
    local timeout=0
    local run_id
    while [[ ${#} -gt 0 ]]; do
        case ${1} in
            -h | --help)
                _subcommand_help wait
                exit 0
                ;;
            -t | --timeout)
                shift
                timeout=${1}
                ;;
            -q | --quiet)
                quiet=true
                ;;
            *)
                run_id="${1}"
                shift
                ;;
        esac
    done

    # Ensure a pipeline id was specified
    if [ -z "${run_id}" ]; then
        echo "error: pipeline run id not specified" >&2
        echo "${usage}" >&2
        return 1
    fi

    # Wait for the pipeline to complete
    local start_time=$(date +%s)
    local elapsed_time=0
    local response status result
    local created_date finished_date
    local pipeline_name run_name branch_name
    while [ "${status}" != "completed" ]; do
        response=$(
            curl "https://dev.azure.com/${ORGANIZATION_ENC}/${PROJECT_ENC}/_apis/pipelines/348/runs/${run_id}?api-version=6.0-preview.1" \
                --silent \
                --user ":${TOKEN}" \
                | python -m json.tool
        )
        state=$(echo "${response}" | grep -oP '(?<="state": ")[^"]+')

        if [ "${state}" != "inProgress" ]; then
            break
        fi

        if [ "${timeout}" -gt 0 ] && [ "${elapsed_time}" -gt "${timeout}" ]; then
            echo "error: timeout waiting for pipeline to complete" >&2
            return 1
        fi
        sleep 5
        elapsed_time=$(($(date +%s) - ${start_time}))
    done

    # Print the pipeline details
    if ! ${quiet}; then
        _subcommand_run-info "${run_id}"
    fi
}

# @description List available pipelines
# @usage list
function _subcommand_list() {
    # Get the pipeline information
    local response=$(
        curl "https://dev.azure.com/${ORGANIZATION_ENC}/${PROJECT_ENC}/_apis/pipelines?api-version=6.0-preview.1" \
            --silent \
            --user ":${TOKEN}" \
            | python -m json.tool
    )

    # Get the pipeline names
    # local pipeline_names=($(echo "${response}" | grep -oP '(?<="name": ")[^"]+'))
    readarray -t pipeline_names < <(echo "${response}" | grep -oP '(?<="name": ")[^"]+')

    # Get the pipeline ids
    # local pipeline_ids=($(echo "${response}" | grep -oP '(?<="id": )[\d]+'))
    readarray -t pipeline_ids < <(echo "${response}" | grep -oP '(?<="id": )[\d]+')

    # Print the pipeline names and ids
    (
        echo $'Name\tID'
        echo $'------\t----'
        for i in "${!pipeline_names[@]}"; do
            echo "${pipeline_names[$i]}"$'\t'"${pipeline_ids[$i]}"
        done | sort
    ) | column -t -s $'\t'
}

# @description Get the id of a pipeline
# @usage get-id <pipeline name>
function _subcommand_get-id() {
    # Parse the arguments
    local pipeline_name
    while [[ ${#} -gt 0 ]]; do
        case ${1} in
            -h|--help)
                _subcommand_help get-id
                exit 0
                ;;
            *)
                pipeline_name="${1}"
                shift
                ;;
        esac
    done

    # Ensure a pipeline name was specified
    if [ -z "${pipeline_name}" ]; then
        echo "error: pipeline name not specified" >&2
        echo "${usage}" >&2
        return 1
    fi

    # Get the lists of pipelines
    local pipelines=$(_subcommand_list | sed -Ee 's/  +/\t/')

    # Get the pipeline id
    local pipeline_id=$(
        echo "${pipelines}" \
            | awk -v pipeline_name="${pipeline_name}" -F $'\t' '$1 == pipeline_name { print $2 }'
    )

    # Ensure the pipeline id was found
    if [ -z "${pipeline_id}" ]; then
        echo "error: pipeline '${pipeline_name}' not found" >&2
        return 1
    fi

    # Print the pipeline id
    echo "${pipeline_id}"
}

# @description Cancel a pipeline run
# @usage cancel <run id> [-h|--help]
function _subcommand_cancel() {
    # Parse the arguments
    local run_id
    while [[ ${#} -gt 0 ]]; do
        case ${1} in
            -h|--help)
                _subcommand_help cancel
                exit 0
                ;;
            *)
                run_id="${1}"
                shift
                ;;
        esac
    done

    # Ensure a pipeline id was specified
    if [ -z "${run_id}" ]; then
        echo "error: pipeline run id not specified" >&2
        echo "${usage}" >&2
        return 1
    fi

    # Cancel the pipeline run
    curl "https://dev.azure.com/${ORGANIZATION_ENC}/${PROJECT_ENC}/_apis/build/builds/${run_id}?api-version=5.1" \
        --silent \
        --user ":${TOKEN}" \
        --request PATCH \
        -H "Content-Type: application/json" \
        --data '{"status": "cancelling"}' \
        | python -m json.tool
}

# @description list all agent pools
# @usage list-pools [-h|--help] [--(no-)json] [--table <separator>]
# @example list-pools --json
# @example list-pools --table $'\t'
function _subcommand_list-pools() {
    # Parse the arguments
    local json=0
    local table_separator=""
    while [[ ${#} -gt 0 ]]; do
        case ${1} in
            -h|--help)
                _subcommand_help list-pools
                exit 0
                ;;
            --json)
                json=1
                table_separator=""
                shift 1
                ;;
            --no-json)
                json=0
                shift 1
                ;;
            --table)
                json=0
                table_separator="${2}"
                shift 2
                ;;
            *)
                echo "error: unknown argument '${1}'" >&2
                echo "${usage}" >&2
                return 1
                ;;
        esac
    done

    # Get the agent pool information
    local response=$(
        curl "https://dev.azure.com/${ORGANIZATION_ENC}/_apis/distributedtask/pools?api-version=7.0" \
            --silent \
            --user ":${TOKEN}" \
            | python -m json.tool
    )

    # Print the agent pool information
    if [[ ${json} -eq 1 ]]; then
        echo "${response}"
    else
        # Parse the agent pool information
        echo "${response}" \
            | awk -v sep="${table_separator}" '
                /"count"/ {
                    # This will be our header if not in table mode
                    if (sep == "") {
                        print "Agent Pools: " gensub(/.*: ([0-9]+).*/, "\\1", "g", $0);
                    } else {
                        print "Name" sep "ID" sep "Size" sep "Created On" sep "Created By" sep "Owner" sep "Hosted";
                    }
                }

                /^ {8}\{/ {
                    # print "Found the beginning of a pool: " $0;
                    if (sep == "") {
                        print "";
                    }
                }
                /"createdOn"/ {
                    pool["createdOn"] = gensub(/.*: "([^"]+)".*/, "\\1", "g", $0);
                }
                /"createdBy"/ {
                    in_user = "creator";
                }
                /"displayName"/ && in_user == "creator" {
                    pool["createdBy"] = gensub(/.*: "([^"]+)".*/, "\\1", "g", $0);
                }
                /"uniqueName"/ && in_user == "creator" {
                    pool["createdByEmail"] = gensub(/.*: "([^"]+)".*/, "\\1", "g", $0);
                    in_user = "";
                }
                /"owner"/ {
                    in_user = "owner";
                }
                /"displayName"/ && in_user == "owner" {
                    pool["owner"] = gensub(/.*: "([^"]+)".*/, "\\1", "g", $0);
                }
                /"uniqueName"/ && in_user == "owner" {
                    pool["ownerEmail"] = gensub(/.*: "([^"]+)".*/, "\\1", "g", $0);
                    in_user = "";
                }
                /"name"/ {
                    pool["name"] = gensub(/.*: "([^"]+)".*/, "\\1", "g", $0);
                }
                /"id"/ {
                    pool["id"] = gensub(/.*: ([0-9]+).*/, "\\1", "g", $0);
                }
                /"isHosted"/ {
                    pool["isHosted"] = gensub(/.*: ([a-z]+).*/, "\\1", "g", $0);
                }
                /"size"/ {
                    pool["size"] = gensub(/.*: ([0-9]+).*/, "\\1", "g", $0);
                }
                /^ {8}\}/ {
                    # print "Found the end of a pool: " $0;
                    # Print the pool
                    if (sep == "") {
                        print pool["name"];
                        print "  ID:         " pool["id"];
                        print "  Size:       " pool["size"];
                        print "  Created On: " pool["createdOn"];
                        print "  Created By: " pool["createdBy"] " <" pool["createdByEmail"] ">";
                        print "  Owner:      " pool["owner"] " <" pool["ownerEmail"] ">";
                        print "  Is Hosted:  " pool["isHosted"];
                    } else {
                        print pool["name"] sep pool["id"] sep pool["size"] sep pool["createdOn"] sep pool["createdBy"] sep pool["createdByEmail"] sep pool["owner"] sep pool["ownerEmail"] sep pool["isHosted"];
                    }
                    # Reset the pool
                    split("", pool);
                }
            '
    fi
}

function _agent_pool_name_to_id() {
    local name="${1}"

    _subcommand_list-pools --table $'\t' \
        | awk -v name="${name}" -F $'\t' '{
            if ($1 == name) {
                print $2;
                exit 0;
            }
            END {
                exit 1;
            }
        }'
}

function _agent_pool_id_to_name() {
    local id="${1}"

    _subcommand_list-pools --table $'\t' \
        | awk -v id="${id}" -F $'\t' '{
            if ($2 == id) {
                print $1;
                exit 0;
            }
            END {
                exit 1;
            }
        }'
}

function _subcommand_agents-in-pool() {
    _agents_in_pool "$@"
}

function _agents_in_pool() {
    local pool_id="${1}"
    local separator="${2}"

    local response=$(
        curl "https://dev.azure.com/${ORGANIZATION_ENC}/_apis/distributedtask/pools/${pool_id}/agents?api-version=7.0" \
            --silent \
            --user ":${TOKEN}"
    )

    # Print out the agent information
    echo "${response}" \
        | awk -v sep="${separator}" '
            /"count"/ {
                # This will be our header if not in table mode
                if (sep == "") {
                    print "(" gensub(/.*: ([0-9]+).*/, "\\1", "g", $0) ")";
                } else {
                    print "Name" sep "ID" sep "Version" sep "Enabled" sep "Status";
                }
            }

            /^ {8}\{/ {
                if (sep == "") {
                    print "";
                }
            }
            /"maxParallelism"/ {
                agent["maxParallelism"] = gensub(/.*: ([0-9]+).*/, "\\1", "g", $0);
            }
            /"name"/ {
                agent["name"] = gensub(/.*: "([^"]+)".*/, "\\1", "g", $0);
            }
            /"version"/ {
                agent["version"] = gensub(/.*: "([^"]+)".*/, "\\1", "g", $0);
            }
            /"enabled"/ {
                agent["enabled"] = gensub(/.*: ([a-z]+).*/, "\\1", "g", $0);
            }
            /"status"/ {
                agent["status"] = gensub(/.*: "([^"]+)".*/, "\\1", "g", $0);
            }
            /"createdOn"/ {
                agent["createdOn"] = gensub(/.*: "([^"]+)".*/, "\\1", "g", $0);
            }
            /"osDescription"/ {
                agent["osDescription"] = gensub(/.*: "([^"]+)".*/, "\\1", "g", $0);
            }
            /"id"/ {
                agent["id"] = gensub(/.*: ([0-9]+).*/, "\\1", "g", $0);
            }
            /^ {8}\}/ {
                # Print the agent
                if (sep == "") {
                    print agent["name"];
                    print "  ID:           " agent["id"];
                    print "  Version:      " agent["version"];
                    print "  Enabled:      " agent["enabled"];
                    print "  Status:       " agent["status"];
                    print "  Created On:   " agent["createdOn"];
                    print "  OS:           " agent["osDescription"];
                    print "  Max Parallel: " agent["maxParallelism"];
                } else {
                    print agent["name"] sep agent["id"] sep agent["version"] sep agent["enabled"] sep agent["status"];
                }
                # Reset the agent
                split("", agent);
            }
        '
}

# @description List all azure agents
# @usage list-agents [-h|--help] [-o|--online] [-O|--offline] [-p|--pool <pool name>]
# @example list-agents
# @example list-agents --offline
# @example list-agents --online --pool "Default" --pool "My Pool"
function _subcommand_list-agents() {
    # Parse the arguments
    local online=0
    local offline=0
    local all_agents=1
    local pools=()
    while [[ ${#} -gt 0 ]]; do
        case ${1} in
            -h|--help)
                _subcommand_help list-agents
                exit 0
                ;;
            -o|--online)
                online=1
                all_agents=0
                shift
                ;;
            -O|--offline)
                offline=true
                all_agents=0
                shift
                ;;
            -p|--pool)
                pools+=("${2}")
                shift 2
                ;;
            *)
                echo "error: unknown argument '${1}'" >&2
                echo "${usage}" >&2
                return 1
                ;;
        esac
    done

    # Get a list of all the pools in the format "<id> <name>"
    local all_pools=()
    readarray -t all_pools < <(_subcommand_list-pools --table $'\t' | awk -F $'\t' 'NR > 1 {print $2 " " $1}')

    # Loop through the pools
    local is_first=0
    for pool in "${all_pools[@]}"; do
        pool_id=$(echo "${pool}" | cut -d ' ' -f 1)
        pool_name=$(echo "${pool}" | cut -d ' ' -f 2-)

        # If we are filtering by pool, skip this pool if it is not in the list
        if [[ ${#pools[@]} -gt 0 ]]; then
            local found=0
            for filter_pool in "${pools[@]}"; do
                if [[ "${filter_pool}" == "${pool_name}" ]]; then
                    found=1
                    break
                fi
            done
            if [[ ${found} -eq 0 ]]; then
                continue
            fi
        fi

        # Get the agents in this pool
        [[ ${is_first} -eq 0 ]] && is_first=1 || echo ""
        local agents=$(
            _agents_in_pool "${pool_id}" $'\t' \
                | awk -v online="${online}" -v offline="${offline}" -v all_agents="${all_agents}" '{
                        print $0;
                }'
        )
        # printf "%s" "${pool_name}"
    done
}

# @description List the N most recent runs of a pipeline
# @usage list-runs [-h|--help] [-n|--number <number>] <pipeline id|name>
function _subcommand_list-runs() {
    # Parse the arguments
    local number=10
    local pipeline
    while [[ ${#} -gt 0 ]]; do
        case ${1} in
            -h|--help)
                _subcommand_help list-runs
                exit 0
                ;;
            -n|--number)
                number="${2}"
                shift 2
                ;;
            *)
                pipeline="${1}"
                shift
                ;;
        esac
    done

    # Ensure a pipeline was specified
    if [ -z "${pipeline}" ]; then
        echo "error: pipeline id not specified" >&2
        echo "${usage}" >&2
        return 1
    fi

    # If the pipeline specified is a name, get the id
    if [[ "${pipeline}" =~ ^[0-9]+$ ]]; then
        pipeline_id="${pipeline}"
    else
        pipeline_id=$(_subcommand_get-id "${pipeline}")
    fi

    # Get the pipeline runs
    local response=$(
        curl "https://dev.azure.com/${ORGANIZATION_ENC}/${PROJECT_ENC}/_apis/pipelines/${pipeline_id}/runs?api-version=6.0-preview.1" \
            --silent \
            --user ":${TOKEN}" \
            | python -m json.tool
    )

    # Get the pipeline run ids
    local run_ids=($(echo "${response}" | grep -oP '(?<="id": )[\d]+' | awk 'NR % 2 == 0'))

    # Get the pipeline run names
    local run_names=($(echo "${response}" | grep -oP '(?<="name": ")[^"]+' | awk 'NR % 2 == 0'))

    # Get the pipeline run created dates
    local run_created_dates=($(echo "${response}" | grep -oP '(?<="createdDate": ")[^"]+'))

    # Get the pipeline run finished dates
    local run_finished_dates=($(echo "${response}" | grep -oP '(?<="finishedDate": ")[^"]+'))

    # Get the pipeline run states
    local run_states=($(echo "${response}" | grep -oP '(?<="state": ")[^"]+'))

    # Get the pipeline run results
    local run_results=($(echo "${response}" | grep -oP '(?<="result": ")[^"]+'))

    # Get the template parameters
    IFS=$'\n' read -r -d '' -a parameters < <(
        echo "${response}" \
            | tr -d '\n' \
            | tr '}' '\n' \
            | grep -o "templateParameters.*" \
            | sed -E 's/.* \{//;s/^\s+//;s/",\s+"/", "/g'
    )

    # Print the pipeline runs
    local TAB=$'\t'
    (
        echo "id${TAB}name${TAB}created${TAB}finished${TAB}duration${TAB}state${TAB}result${TAB}parameters"
        for i in "${!run_ids[@]}"; do
            # Calculate the duration
            local duration_seconds=$(($(date -d "${run_finished_dates[$i]}" +%s) - $(date -d "${run_created_dates[$i]}" +%s)))
            local duration=$(date -u -d @${duration_seconds} +"%H:%M:%S")
            echo "${run_ids[$i]}${TAB}${run_names[$i]}${TAB}${run_created_dates[$i]}${TAB}${run_finished_dates[$i]}${TAB}${duration}${TAB}${run_states[$i]}${TAB}${run_results[$i]}${TAB}${parameters[$i]}"
        done
    ) | head -n "$((number + 1))" | column -t -s $'\t'
}

# @description Run a pipeline with the specified name or id
# @usage run [-h|--help] [-v variable=value] [-p parameter=value] [-b branch] [-w|--wait] <pipeline id|name>
function _subcommand_run() {
    # Parse the arguments
    local branch=${AZURE_BRANCH:-master}
    local variables=()
    local parameters=()
    local pipeline_name
    local wait=0
    while [[ ${#} -gt 0 ]]; do
        case ${1} in
            -h|--help)
                _subcommand_help run
                exit 0
                ;;
            -v|--variable)
                variables+=("${2}")
                shift 2
                ;;
            -p|--parameter)
                parameters+=("${2}")
                shift 2
                ;;
            -b|--branch)
                branch="${2}"
                shift 2
                ;;
            -w|--wait)
                wait=1
                ;;
            *)
                pipeline_name="${1}"
                shift 1
                ;;
        esac
    done

    debug "pipeline_name: ${pipeline_name}"
    debug "branch: ${branch}"
    debug "variables: $(printf "%q " "${variables[@]}")"
    debug "parameters: $(printf "%q " "${parameters[@]}")"
    debug "wait: ${wait}"

    # Ensure a pipeline name was specified
    if [ -z "${pipeline_name}" ]; then
        echo "error: pipeline name not specified" >&2
        echo "${usage}" >&2
        return 1
    fi

    # Get the pipeline id
    local pipeline_id=$(_subcommand_get-id "${pipeline_name}")

    # Ensure the pipeline id was found
    if [ -z "${pipeline_id}" ]; then
        echo "error: pipeline '${pipeline_name}' not found" >&2
        return 1
    fi

    # Run the pipeline
    # echo curl "https://dev.azure.com/${ORGANIZATION_ENC}/${PROJECT_ENC}/_apis/pipelines/${pipeline_id}/runs?api-version=6.0-preview.1" \
    #         --header "Content-Type: application/json" \
    #         --user ":${TOKEN}" \
    #         --data '{   
    #             "stagesToSkip":[],
    #             "resources":
    #             {
    #                 "repositories":
    #                 {
    #                     "self":{"refName":"refs/heads/'"${branch}"'"}
    #                 }

    #             },
    #             "templateParameters": '"$(key-value-array-to-json "${parameters[@]}")"',
    #             "variables": '"$(key-value-array-to-json "${variables[@]}")"'
    #         }'
    response=$(
        curl "https://dev.azure.com/${ORGANIZATION_ENC}/${PROJECT_ENC}/_apis/pipelines/${pipeline_id}/runs?api-version=6.0-preview.1" \
            --header "Content-Type: application/json" \
            --user ":${TOKEN}" \
            --data '{   
                "stagesToSkip":[],
                "resources":
                {
                    "repositories":
                    {
                        "self":{"refName":"refs/heads/'"${branch}"'"}
                    }

                },
                "templateParameters": '"$(key-value-array-to-json "${parameters[@]}")"',
                "variables": '"$(key-value-array-to-json "${variables[@]}")"'
            }' \
            | python -m json.tool
    )

    echo "${response}"

    # Get the pipeline run id
    local run_id=$(echo "${response}" | grep -oP '(?<="id": )[\d]+' | tail -1)

    # Wait for the pipeline to finish
    if [ "${wait}" -eq 1 ]; then
        echo "Waiting for pipeline to finish ... "
        _subcommand_wait "${run_id}"
    fi
}

# @description Cancel a pipeline run
# @usage cancel <run id>
function _subcommand_cancel() {
    local run_id="${1}"

    # Parse the arguments
    curl "https://dev.azure.com/${ORGANIZATION_ENC}/${PROJECT_ENC}/_apis/build/builds/${run_id}?api-version=6.0" \
        --silent \
        --request PATCH \
        --header "Content-Type: application/json" \
        --user ":${TOKEN}" \
        --data '{ "status": "cancelling" }'
}

# @description Get the build log for a pipeline run
# @usage run-log <run id> <log id>
function _subcommand_log() {
    local run_id="${1}"
    local log_id="${2}"

    # Parse the arguments
    curl "https://dev.azure.com/${ORGANIZATION_ENC}/${PROJECT_ENC}/_apis/build/builds/${run_id}/logs/${log_id}?api-version=6.0" \
        --silent \
        --header "Content-Type: text/plain" \
        --user ":${TOKEN}"
}

# @description List the available logs for a pipeline run
# @usage logs <run id>
function _subcommand_logs() {
    local run_id="${1}"

    # Parse the arguments
    curl "https://dev.azure.com/${ORGANIZATION_ENC}/${PROJECT_ENC}/_apis/build/builds/${run_id}/logs?api-version=6.0" \
        --silent \
        --header "Content-Type: application/json" \
        --user ":${TOKEN}" \
        | python -m json.tool
}

# @description Send a GET request to the specified URL and return the response
# @usage get <url>
function _subcommand_get() {
    local url="${1}"

    # Send the request
    data=$(curl "${url}" \
        --silent \
        --header "Content-Type: application/json" \
        --user ":${TOKEN}")
    
    # Try to parse the response as JSON
    echo "${data}" | python -m json.tool 2>/dev/null || echo "${data}"
}

# @description Send a POST request to the specified URL and return the response
# @usage post <url> [curl options]
function _subcommand_post() {
    local url="${1}"
    shift

    # Send the request
    data=$(curl \
        --silent \
        --header "Content-Type: application/json" \
        --user ":${TOKEN}" \
        "$@" \
        "${url}")
    
    # Try to parse the response as JSON
    echo "${data}" | python -m json.tool 2>/dev/null || echo "${data}"
}

# @description Download the logs as a zip file for the specified pipeline run
# @usage download-logs [-o|--output <path>] <run id>
function _subcommand_download-logs() {
    local run_id

    # Parse the arguments
    local output

    while [[ ${#} -gt 0 ]]; do
        case ${1} in
            -h|--help)
                _subcommand_help download-logs
                exit 0
                ;;
            -o|--output)
                shift
                output="${1}"
                ;;
            *)
                if [ -z "${run_id}" ]; then
                    run_id="${1}"
                else
                    echo "error: unexpected argument '${1}'" >&2
                    echo "${usage}" >&2
                    return 1
                fi
                shift
                ;;
        esac
    done

    # Ensure a run id was specified
    if [ -z "${run_id}" ]; then
        echo "error: run id not specified" >&2
        echo "${usage}" >&2
        return 1
    fi

    # Get the run info
    local run_info=$(_subcommand_run-info "${run_id}")
    local pipeline_name=$(echo "${run_info}" | grep -oP '^Pipeline: +\K.*')
    local run_name=$(echo "${run_info}" | grep -oP '^Run: +\K.*')
    local created_date=$(echo "${run_info}" | grep -oP '^Finished: +\K.*')
    local branch_name=$(echo "${run_info}" | grep -oP '^Branch: +refs/heads/\K.*' | tr '/' '_')
    echo "${run_info}"

    # If no output file specified, use the run info
    if [ -z "${output}" ]; then
        # Make sure we have the required info
        if [ -z "${pipeline_name}" ] || [ -z "${run_name}" ] || [ -z "${created_date}" ]; then
            echo "error: unable to determine output file name" >&2
            return 1
        fi
        output="${pipeline_name}_${run_name}_${run_id}_$(date -d "${created_date}" "+%Y%m%d-%H%M%S")_${branch_name}.zip"
    fi
    echo
    echo "Downloading logs to ${output} ..."

    # Download the logs
    curl "https://dev.azure.com/${ORGANIZATION_ENC}/${PROJECT_ENC}/_apis/build/builds/${run_id}/logs?\$format=zip" \
        --user ":${TOKEN}" \
        --output "${output}"
}

# @description Create a pull request from / to the specified branches
# @usage pr <source branch> <target branch> [title] [description]
function _subcommand_pr-create() {
    local source_branch="${1}"
    local target_branch="${2}"
    local title="${3:-"Merge ${source_branch} into ${target_branch}"}"
    local description="${4}"

    # Parse the arguments
    curl "https://dev.azure.com/${ORGANIZATION_ENC}/${PROJECT_ENC}/_apis/git/repositories/${REPO_ENC}/pullrequests?api-version=6.0" \
        --silent \
        --request POST \
        --header "Content-Type: application/json" \
        --user ":${TOKEN}" \
        --data '{
            "sourceRefName": "refs/heads/'"${source_branch}"'",
            "targetRefName": "refs/heads/'"${target_branch}"'",
            "title": "'"${title}"'",
            "description": "'"${description}"'"
        }' \
            | python -m json.tool
}

# @description Generate a link to a pull request given its id
# @usage pr-link <pr id>
function _subcommand_pr-link() {
    local pr_id="${1}"

    # Parse the arguments
    echo "https://dev.azure.com/${ORGANIZATION_ENC}/${PROJECT_ENC}/_git/${REPO_ENC}/pullrequest/${pr_id}"
}

# @description Approve a pull request
# @usage pr-approve <pr id>
function _subcommand_pr-approve() {
    local pr_id="${1}"

    # Parse the arguments
    curl "https://dev.azure.com/${ORGANIZATION_ENC}/${PROJECT_ENC}/_apis/git/repositories/${REPO_ENC}/pullrequests/${pr_id}/reviewers?api-version=6.0" \
        --silent \
        --request POST \
        --header "Content-Type: application/json" \
        --user ":${TOKEN}" \
        --data "{ \"vote\": 10, \"id\": \"${AZURE_USER_ID}\" }" \
            | python -m json.tool
}

# @description Get the status of a pull request
# @usage pr-status <pr id>
function _subcommand_pr-status() {
    local pr_id="${1}"

    # Parse the arguments
    curl "https://dev.azure.com/${ORGANIZATION_ENC}/${PROJECT_ENC}/_apis/git/repositories/${REPO_ENC}/pullrequests/${pr_id}?api-version=6.0" \
        --silent \
        --user ":${TOKEN}" \
            | python -m json.tool
}

# @description Set a pull request to auto-complete
# @usage pr-auto-complete <pr id> [title]
function _subcommand_pr-auto-complete() {
    local pr_id="${1}"
    local title_suffix="${2}"
    local title="Merged PR ${pr_id}"
    if [ -n "${title_suffix}" ]; then
        title="${title}: ${title_suffix}"
    fi

    json='{
            "autoCompleteSetBy": {
                "id": "'${AZURE_USER_ID}'"
            },
            "completionOptions": {
                "mergeCommitMessage": "'${title}'",
                "deleteSourceBranch": false,
                "mergeStrategy": "noFastForward"
            }
        }'
    debug "json: ${json}"
    # Set the pull request to auto-complete
    curl "https://dev.azure.com/${ORGANIZATION_ENC}/${PROJECT_ENC}/_apis/git/repositories/${REPO_ENC}/pullrequests/${pr_id}?api-version=6.0" \
        --silent \
        --request PATCH \
        --header "Content-Type: application/json" \
        --user ":${TOKEN}" \
        --data "${json}" \
            | python -m json.tool
}

# @description Complete a pull request
# @usage pr-complete <pr id>
function _subcommand_pr-complete() {
    local pr_id="${1}"
    local lmsc="${2}"

    # Complete the pull request
    curl "https://dev.azure.com/${ORGANIZATION_ENC}/${PROJECT_ENC}/_apis/git/repositories/${REPO_ENC}/pullrequests/${pr_id}?api-version=5.0" \
        --silent \
        --request PATCH \
        --header "Content-Type: application/json" \
        --user ":${TOKEN}" \
        --data '{ "LastMergeSourceCommit": "'"${lsmc}"'" }' \
            | python -m json.tool
}

# @description Create a pull request from / to the specified branches and auto-complete it
# @usage pr <source branch> <target branch> [title] [description]
function _subcommand_pr() {
    local pr_id

    # Create the pull request and get the id
    while IFS= read line; do
        # Check for the pull request id
        if [[ -z "${pr_id}" && "${line}" =~ "pullRequestId" ]]; then
            pr_id="$(echo "${line}" | sed -E 's/.*: ([0-9]+),/\1/')"
        fi
        echo "${line}"
    done < <(_subcommand_pr-create "${@}")

    # Set the pull request to auto-complete
    if [[ -n "${pr_id}" ]]; then
        _subcommand_pr-auto-complete "${pr_id}"
    else
        echo "error: failed to create pull request" >&2
        return 1
    fi
}

# @description Cancel a pull request
# @usage pr-cancel <pr id>
function _subcommand_pr-cancel() {
    local pr_id="${1}"

    [[ -z "${pr_id}" ]] && { echo "error: Missing pull request id" >&2; return 1; }

    # Cancel the pull request
    curl "https://dev.azure.com/${ORGANIZATION_ENC}/${PROJECT_ENC}/_apis/git/repositories/${REPO_ENC}/pullrequests/${pr_id}?api-version=5.0" \
        --silent \
        --request PATCH \
        --header "Content-Type: application/json" \
        --user ":${TOKEN}" \
        --data '{ "status": "abandoned" }' \
            | python -m json.tool
}

# @description List all pull requests
# @usage pr-list
function _subcommand_pr-list() {
    # Parse the arguments
    curl "https://dev.azure.com/${ORGANIZATION_ENC}/${PROJECT_ENC}/_apis/git/repositories/${REPO_ENC}/pullrequests?api-version=6.0" \
        --silent \
        --user ":${TOKEN}" \
            | python -m json.tool
}

# @description Print the usage message or the help message for a subcommand
# @args [<subcommand>]
function _subcommand_help() {
    # Default arguments
    local subcommands=()
    local do_minimal=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "${1}" in
            -m|--minimal)
                do_minimal=true
                shift 1
                ;;
            *)
                subcommands+=("${1}")
                shift 1
                ;;
        esac
    done

    debug "subcommands: ${subcommands[@]}"
    debug "do_minimal: ${do_minimal}"

    # If no subcommand was specified, then print the help message
    if [[ ${#subcommands[@]} -eq 0 ]]; then
        debug "Getting subcommands from ${0}"
        # Parse for all the subcommands
        # local subcommands=()
        # while IFS= read -r line; do
        #     if [[ "${line}" =~ ^_subcommand_[A-za-z0-9_-]+" (" ]]; then
        #         subcommands+=($(echo "${line}" | grep -oP "_subcommand_\K[a-z_-]+"))
        #     fi
        # done < "${0}"
        readarray -t subcommands < <(
            grep -oP "_subcommand_\K[a-z_-]+" "${0}" | sort | uniq
        )
        if ${do_minimal}; then
            printf "%s\n" "${subcommands[@]}"
            return 0
        fi
        echo "usage: $(basename "${0}") <subcommand> [options]"
        echo
        echo "Available subcommands:"
        printf "    %s\n" "${subcommands[@]}"
        echo
        echo "For help with a specific subcommand, run:"
        echo "    $(basename "${0}") help <subcommand>"
    else
        local is_first=true
        for subcommand in "${subcommands[@]}"; do
            ${is_first} && is_first=false || printf '\n---\n\n'
            # Determine if the subcommand is an alias for another subcommand
            local code=$(type "_subcommand_${subcommand}" 2>/dev/null)
            if grep -qE "^    _subcommand_" <<< "${code}"; then
                subcommand=$(echo "${code}" | grep -oP "^    _subcommand_\K[a-z_-]+")
            fi

            debug "subcommand: ${subcommand}"

            # Otherwise, use awk to print the help message for the specified
            # subcommand
            awk -v subcommand="${subcommand}" -v prog="$(basename "${0}")" '
                BEGIN {
                    # used to track the current help name for multi-line fields
                    cur_help_name = "";
                }
                # Define a function that wraps text to a specified width
                function wrap(text, width) {
                    # If the text is longer than the width, then wrap it
                    if (length(text) > width) {
                        # Split the text into words
                        split(text, words, " ");

                        # Loop through the words and add them to the line
                        line = "";
                        for (i in words) {
                            # If the line is empty, then add the word
                            if (length(line) == 0) {
                                line = words[i];
                            } else if (length(line) + length(words[i]) + 1 <= width) {
                                # If the line is not empty and the word will fit on
                                # the line, then add the word
                                line = line " " words[i];
                            } else {
                                # Otherwise, print the line and start a new line
                                print line;
                                line = words[i];
                            }
                        }

                        # Print the last line
                        print line;
                    } else {
                        # Otherwise, just print the text
                        print text;
                    }
                }
                {
                    # Store any lines that start with "# @"
                    if ($0 ~ /^# @/) {
                        help_name = gensub(/^# @([a-z-]+).*/, "\\1", "g", $0);
                        help_text = gensub(/^# @([a-z-]+) (.*)/, "\\2", "g", $0);
                        cur_help_name = help_name;
                        help[help_name] = help_text;
                    } else if ($0 ~ /^function/) {
                        # If we find a function, either print the help message or
                        # clear the help message
                        cur_help_name = "";
                        found_cmd = gensub(/^function _subcommand_([a-z_-]+).*/, "\\1", "g", $0);
                        if (found_cmd == subcommand) {
                            # If there is no help message, then say as much
                            if (length(help) == 0) {
                                exit 2;
                            }
                            # If there is a description, print and delete it
                            if (help["description"]) {
                                print wrap(help["description"], 80);
                                delete help["description"];
                            } else {
                                delete help["description"];
                            }
                            # If there are args, print and delete them
                            if (help["args"] != "") {
                                print "usage: " prog " " subcommand " " help["args"];
                                delete help["args"];
                            } else {
                                delete help["args"];
                            }
                            # Loop over the remaining help messages and print them
                            for (help_name in help) {
                                print help_name ": " help[help_name];
                            }
                            exit;
                        } else {
                            split("", help);
                        }
                    } else if (cur_help_name != "" && $0 ~ /^# /) {
                        # If we are in a multi-line field, then append the line to
                        # the current help message
                        help_text = gensub(/^#\s+(.*)/, "\\1", "g", $0);
                        help[cur_help_name] = help[cur_help_name] " " help_text;
                    }
                }
                END {
                    if (found_cmd != subcommand) {
                        exit 1;
                    }
                }
            ' "${BASH_SOURCE[0]}"
            local exit_code=${?}
            case ${exit_code} in
                0)
                    # Do nothing
                    ;;
                1)
                    echo-stderr "error: no such subcommand '${subcommand}'"
                    ;;
                2)
                    echo-stderr "error: no help message found for subcommand '${subcommand}'"
                    ;;
                *)
                    echo-stderr "error: awk exited with code ${exit_code}"
                    ;;
            esac
        done
    fi
    exit ${exit_code}
}

# @description List all projects in the configured organization
# @usage list-projects
function _subcommand_list-projects() {
    # Output will be in the format:
    #  <organization>/<project> <url>
    #  <organization>/<project> <url>
    #  ...

    # Get the list of projects
    # GET https://dev.azure.com/{organization}/_apis/projects?api-version=7.0
    local projects_json=$(
        curl "https://dev.azure.com/${ORGANIZATION_ENC}/_apis/projects?api-version=7.0" \
            --silent \
            --user ":${TOKEN}"
    )
    readarray -t projects_names < <(
        echo "${projects_json}" \
            | python -m json.tool \
            | grep -Po '"name": "\K[^"]+'
    )

    # Print the list of projects
    for project in "${projects_names[@]}"; do
        echo "${ORGANIZATION}/${project} https://dev.azure.com/${ORGANIZATION}/$(urlencode "${project}")"
    done
}

# @description List all repos in the configured organization
# @usage list-repo
function _subcommand_list-repos() {
    # Output will be in the format:
    #  <organization>/<project>/<repo> <url>
    #  <organization>/<project>/<repo> <url>
    #  ...

    # Get the list of projects
    # GET https://dev.azure.com/{organization}/_apis/projects?api-version=7.0
    local projects_json=$(
        curl "https://dev.azure.com/${ORGANIZATION_ENC}/_apis/projects?api-version=7.0" \
            --silent \
            --user ":${TOKEN}"
    )
    readarray -t projects_names < <(
        echo "${projects_json}" \
            | python -m json.tool \
            | grep -Po '"name": "\K[^"]+'
    )

    # For each project, get the list of repos
    # GET https://dev.azure.com/{organization}/{project}/_apis/git/repositories?includeLinks={includeLinks}&includeAllUrls={includeAllUrls}&includeHidden={includeHidden}&api-version=7.0
    for project in "${projects_names[@]}"; do
        local repos_json=$(
            curl "https://dev.azure.com/${ORGANIZATION_ENC}/$(urlencode "${project}")/_apis/git/repositories?api-version=7.0" \
                --silent \
                --user ":${TOKEN}"
        )
        readarray -t repos_names < <(
            echo "${repos_json}" \
                | python -m json.tool \
                | grep -Po '"name": "\K[^"]+' \
                | awk 'NR%2==1' # Only get every other line (the repo names)
        )
        for repo in "${repos_names[@]}"; do
            printf "%s/%s/%s %s\n" \
                "${ORGANIZATION}" \
                "${project}" \
                "${repo}" \
                "https://dev.azure.com/${ORGANIZATION_ENC}/$(urlencode "${project}")/_git/repositories/$(urlencode "${repo}")"
        done
    done
}

## main ########################################################################
################################################################################

function main() {
    # Parse the arguments
    parse-args "${@}"

    local subcommand_func="_subcommand_${SUBCOMMAND}"
    # Determine if the subcommand function exists
    if ! declare -f "${subcommand_func}" > /dev/null; then
        echo "error: unknown subcommand '${SUBCOMMAND}'" >&2
        echo "usage: $(functionname 2) <subcommand> [<args>]" >&2
        return 1
    fi

    # Run the subcommand
    debug "running subcommand '${SUBCOMMAND}' with args '${SUBCOMMAND_ARGS[*]}'"
    "${subcommand_func}" "${SUBCOMMAND_ARGS[@]}"
}


## run #########################################################################
################################################################################

[ "${BASH_SOURCE[0]}" == "${0}" ] && main "${@}"
