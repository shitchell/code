#!/usr/bin/env bash

TRI_REPO="${1%%/}"
OPG_REPO="${2%%/}"
RELEASE_FILES="${3}"

usage() {
	echo "usage: $(basename "$0") <trinoor repo> <opg repo> [file list]"
}

# Ensure that the specified repos and file are all valid
if [ ! -d "${TRI_REPO}/.git" ]; then
	echo "error: '${TRI_REPO}' is not a valid repo" >&2
	usage >&2
	exit 1
fi
if [ ! -d "${OPG_REPO}/.git" ]; then
	echo "error: '${OPG_REPO}' is not a valid repo" >&2
	usage >&2
	exit 1
fi
if [ -n "${RELEASE_FILES}" ] && [ ! -f "${RELEASE_FILES}" ]; then
	echo "error: '${RELEASE_FILES}' is not a valid file" >&2
	usage >&2
	exit 1
fi

# colored output
GREEN="\033[32m"
RED="\033[31m"
BLUE="\033[34m"
PURPLE="\033[35m"
CYAN="\033[36m"
RESET="\033[0m"

# echo a command before running it
echo-run() {
        command="$@"
        echo -e "${GREEN}${command}${RESET}"
        "$@"
        exit_code="$?"

        if [ $exit_code -ne 0 ]; then
                echo -e "${RED}command exited with status ${exit_code}${RESET}"
        fi
        return $exit_code
}

# Display information about how files will be copied to the OPG repository
echo -n "Sync Strategy: "
if [ -z "${RELEASE_FILES}" ]; then
	echo "full sync"
else
	display_rows=17
	echo "file list '${RELEASE_FILES}'"
	cat "${RELEASE_FILES}" \
		| sort \
		| uniq \
		| head -n ${display_rows} \
		| tr -d '\r' \
		| sed 's/.*/- &/g'
	lines="$(cat "${RELEASE_FILES}" | sort | uniq | wc -l)"
	if [ ${lines} -gt ${display_rows} ]; then
		echo "- ... $((lines - display_rows)) lines omitted"
	fi
fi
echo
echo "This will reset both '$(basename "${TRI_REPO}")' and '$(basename "${OPG_REPO}")' to be in sync with origin."
echo "Any unpushed changes will be lost!"
read -p "Do you wish to proceed? (yes/no) " yn

if ! [[ "${yn::1}" =~ [Yy] ]]; then
	echo "such a tease :("
	exit 1
fi

# save the current directory to return here
cwd=$(pwd)

# ensure the trinoor repository is on the release branch and in sync with origin
echo-run cd "$TRI_REPO"
tri_branch=$(git symbolic-ref --short -q HEAD)
if [ "${tri_branch}" != "release" ]; then
	echo-run git checkout release
else
	echo -e "${BLUE}release branch already checked out${RESET}"
fi
echo-run git reset --hard HEAD \
	&& echo-run git clean -fd \
	&& echo-run git pull \
	&& echo "successfully reset '${TRI_REPO}'"
[ $? -ne 0 ] && echo "errors updating '${TRI_REPO}', exiting" && exit 1
cd "${cwd}"

# ensure the OPG repository is on the AS9-Trinoor-Dev branch and in sync with origin
echo-run cd "${OPG_REPO}"
opg_branch=$(git symbolic-ref --short -q HEAD)
if [ "${opg_branch}" != "AS9-Trinoor-Dev" ]; then
	echo-run git checkout AS9-Trinoor-Dev
else
	echo -e "${BLUE}AS9-Trinoor-Dev branch already checked out${RESET}"
fi
echo-run git reset --hard HEAD \
	&& echo-run git clean -fd \
	&& echo-run git pull \
	&& echo "successfully reset '${OPG_REPO}'"
[ $? -ne 0 ] && echo "errors updating '${OPG_REPO}', exiting" && exit 1

# return to the original directory
cd "${cwd}"

directories="
customization_metadata
app_config
database
tailored
tests
nxa
helix
documents"

if [ -n "${RELEASE_FILES}" ]; then
	files=$(cat $RELEASE_FILES | sort | uniq)
else
	cd "${TRI_REPO}"
	files=$(find ${directories} -type f)
	cd "${cwd}"
fi

# determine total number of files
total_files=$(echo "${files}" | wc -l)
copied_files=0

# ensure that piping doesn't mess up our copied_files count
shopt -s lastpipe

# Display a message about which sync strategy is being used
if [ -n "${RELEASE_FILES}" ]; then
	echo -e "${BLUE}Copying files in file list '${RELEASE_FILES}'${RESET}"
else
	echo -e "${BLUE}Copying all files in '${TRI_REPO}'${RESET}"
fi

last_transfer_err=0 # was the last file transfer successful?
transfer_err="" # error message during transfer
while read -r filepath; do
	OPG_FILE="${OPG_REPO}/${filepath}"
	TRI_FILE="${TRI_REPO}/${filepath}"

	# copy, delete, or skip the file
	if [ ! -f "${TRI_FILE}" ] && [ -f "${OPG_FILE}" ]; then
		# if the TRI file doesn't exist, but the OPG file does, delete the OPG file
		transfer_err=$(rm "${OPG_FILE}" 2>&1)
	elif [ -f "${TRI_FILE}" ]; then
		# copy the TRI file to the OPG repository
		# ensure the OPG directory exists
		mkdir -p "$(dirname "${OPG_FILE}")"
		transfer_err=$(cp "${TRI_FILE}" "${OPG_FILE}" 2>&1)
	else
		# neither file exists, so skip it
		transfer_err="'${filepath}' doesn't exist in either repository"
	fi

	# update the copied_files count
	let copied_files++

	# handle any errors
	if [ -n "${transfer_err}" ]; then
		if [ "${last_transfer_err}" -eq 0 ] && [ -n "${prev_line_len}" ]; then
			# if the last transfer was not an error, and this isn't the first
			# transfer, then echo a newline away from the last transfer message
			echo
		fi
		echo -e "${RED}${transfer_err}${RESET}"
		last_transfer_err=1
		continue
	else
		last_transfer_err=0
	fi

	# update the progress bar
	line="${copied_files} / ${total_files} -- ${filepath}"
	# erase the previous line
	echo -n $'\r'
	printf "%${prev_line_len}s"
	# show the current line
	echo -n $'\r'"${line}"
	prev_line_len="$(echo "${line}" | wc -c)"

    # check if the file was a java class, in the db directory, or an ftp script
    if is-java-class "${filepath}" >/dev/null 2>&1; then
        echo
        echo "- java class"
    elif [[ "${filepath}" =~ ^"database/" ]]; then
        echo
        echo "- database file"
    elif [[ "${filepath}" =~ ^"app_config/FTP_SCRIPTS/" ]]; then
        echo
        echo "- ftp script"
    fi
done <<< "${files}"

shopt -u lastpipe

echo
echo "Now go commit and push!"
