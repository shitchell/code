#!/usr/bin/env bash
#
# Manipulate the clipboard via powershell


## imports #####################################################################
################################################################################

include-source 'colors.sh'
include-source 'debug.sh'
include-source 'wsl.sh'


## pipes #######################################################################
################################################################################

[ -t 0 ] && __FD_STDIN=false  || __FD_STDIN=true
[ -t 1 ] && __FD_STDOUT=false || __FD_STDOUT=true
[ -t 2 ] && __FD_STDERR=false || __FD_STDERR=true


## exit codes ##################################################################
################################################################################

declare -ri E_SUCCESS=0
declare -ri E_ERROR=1
declare -ri E_BINARY_FILE=2
declare -ri E_MISSING_DEPENDENCY=3


## traps #######################################################################
################################################################################

function silence-output() {
    :  'Silence all script output'
    exec 3>&1 4>&2 1>/dev/null 2>&1
}

function restore-output() {
    :  'Restore script output after a call to silence-output'
    [[ -t 3 ]] && exec 1>&3 3>&-
    [[ -t 4 ]] && exec 2>&4 4>&-
}

function trap-exit() {
    :  'An exit trap to restore output on script end'
    restore-output
}
trap trap-exit EXIT


## usage functions #############################################################
################################################################################

function help-usage() {
    echo "usage: $(basename "${0}") [-h] [--format <fmt>] [--highlight] [-f <file>] [content]"
}

function help-epilogue() {
    echo "view or update the Windows clipboard contents"
}

function help-full() {
    help-usage
    help-epilogue
    echo
    echo "Copy content to the clipboard with optional format conversion, or paste"
    echo "clipboard contents in various formats."
    echo
    echo "Options:"
    cat << EOF
    -h                    display usage
    --help                display this help message
    --config-file <file>  use the specified configuration file
    -c/--color <when>     when to use color ("auto", "always", "never")
EOF
    echo
    echo "Input options (copy to clipboard):"
    cat << EOF
    -f/--file <file>      copy the contents of <file> to the clipboard
    -a/--append           append to the clipboard instead of replacing it
    --value <value>       copy the specified value to the clipboard
    --copy/--set          explicitly set copy mode
    --format <fmt>        input format: text, html, markdown, csv, auto
                          (default: text, or auto with --file)
    --highlight           enable syntax highlighting (requires pygmentize)
                          auto-detects language from file extension or shebang
    --lang <language>     specify language for syntax highlighting
                          (overrides auto-detection, see pygmentize -L)
EOF
    echo
    echo "Output options (paste from clipboard):"
    cat << EOF
    --paste/--get         explicitly set paste mode (default if no input)
    --raw                 output the raw clipboard contents
    --text                output in plain text format (default)
    --unicode             output in Unicode format
    --html                output in HTML format
    --md                  output in Markdown format (converts HTML via pandoc)
    --rtf                 output in RTF format
    --csv                 output in CSV format
    --image               output in image format
    --audio               output in audio format
EOF
}

function parse-args() {
    CONFIG_FILE="${HOME}/.$(basename "${0}").conf"
    for ((i=0; i<${#}; i++)); do
        case "${!i}" in
            -c | --config-file)
                let i++
                CONFIG_FILE="${!i}"
                ;;
        esac
    done
    [[ -f "${CONFIG_FILE}" ]] && source "${CONFIG_FILE}"

    DO_COLOR=false
    FILEPATH=""
    DO_APPEND=false
    DO_HIGHLIGHT=false
    HIGHLIGHT_LANG=""
    COPY_CONTENTS=""
    COPY_SOURCE=""
    IO=""
    local default_io="paste"
    INPUT_FORMAT=""
    OUTPUT_FORMAT='text'
    local color_when="${COLOR:-auto}"

    local file_contents=()
    local args_contents=()
    local stdin_contents=()
    while [[ ${#} -gt 0 ]]; do
        case ${1} in
            -h)
                help-usage
                help-epilogue
                exit ${E_SUCCESS}
                ;;
            --help)
                help-full
                exit ${E_SUCCESS}
                ;;
            --config-file)
                shift 1
                ;;
            -c | --color)
                color_when="${2}"
                shift 1
                ;;
            -f | --file)
                FILEPATH="${2}"
                IO="copy"
                shift 1
                ;;
            -a | --append)
                DO_APPEND=true
                ;;
            --value)
                args_contents=( "${2}" )
                IO="copy"
                shift 1
                ;;
            --copy | --set)
                IO="copy"
                ;;
            --paste | --get)
                IO="paste"
                ;;
            --format)
                INPUT_FORMAT="${2}"
                shift 1
                ;;
            --highlight)
                DO_HIGHLIGHT=true
                ;;
            --lang)
                HIGHLIGHT_LANG="${2}"
                DO_HIGHLIGHT=true
                shift 1
                ;;
            --raw | --text | --unicode | --html | --md | --rtf | --csv | \
            --image | --audio)
                OUTPUT_FORMAT="${1:2}"
                ;;
            --)
                shift 1
                break
                ;;
            -*)
                echo "error: unknown option: ${1}" >&2
                return ${E_ERROR}
                ;;
            *)
                args_contents+=( "${1}" )
                IO="copy"
                ;;
        esac
        shift 1
    done

    while [[ ${#} -gt 0 ]]; do
        args_contents+=( "${1}" )
        shift 1
    done

    if ${__FD_STDIN} && [[ -z "${IO}" ]]; then
        stdin_contents+=( "$(cat)" )
        IO="copy"
    elif ${__FD_STDIN} && [[ "${IO}" == "copy" ]]; then
        stdin_contents+=( "$(cat)" )
    fi

    if [[ -n "${FILEPATH}" ]]; then
        COPY_CONTENTS=$(<"${FILEPATH}")
        COPY_SOURCE="file"
    elif [[ ${#args_contents[@]} -gt 0 ]]; then
        COPY_CONTENTS="${args_contents[*]}"
        COPY_SOURCE="args"
    elif [[ ${#stdin_contents[@]} -gt 0 ]]; then
        COPY_CONTENTS="${stdin_contents[@]}"
        COPY_SOURCE="stdin"
    fi

    case "${color_when}" in
        on | yes | always)
            DO_COLOR=true
            ;;
        off | no | never)
            DO_COLOR=false
            ;;
        auto)
            if ${__IN_TERMINAL}; then
                DO_COLOR=true
            else
                DO_COLOR=false
            fi
            ;;
        *)
            echo "error: invalid color mode: ${color_when}" >&2
            return ${E_ERROR}
            ;;
    esac
    ${DO_COLOR} && setup-colors || unset-colors

    [[ -z "${IO}" ]] && IO="${default_io}"

    return ${E_SUCCESS}
}


## dependency helpers ##########################################################
################################################################################

function require-pandoc() {
    :  'Check that pandoc is available, error if not'
    if ! command -v pandoc &>/dev/null; then
        echo "error: pandoc not found (install: apt install pandoc)" >&2
        return ${E_MISSING_DEPENDENCY}
    fi
}

function require-pygmentize() {
    :  'Check that pygmentize is available, error if not'
    if ! command -v pygmentize &>/dev/null; then
        echo "error: pygmentize not found (install: pip install Pygments)" >&2
        return ${E_MISSING_DEPENDENCY}
    fi
}


## helpful functions ###########################################################
################################################################################

function is-binary-file() {
    :  'Check if a file is binary
        @arg $1 - file path
        @stdout - mime type (for error messages)
        @return 0 if binary, 1 if text
    '
    local filepath="$1"
    local mime_type
    mime_type=$(file -b --mime-type "${filepath}")
    echo "${mime_type}"
    [[ "${mime_type}" != text/* && "${mime_type}" != application/json && "${mime_type}" != application/xml && "${mime_type}" != application/csv ]]
}

function detect-format-from-extension() {
    local filepath="$1"
    case "${filepath,,}" in
        *.md | *.markdown)
            echo "markdown"
            ;;
        *.csv)
            echo "csv"
            ;;
        *.html | *.htm)
            echo "html"
            ;;
        *)
            echo "text"
            ;;
    esac
}

function detect-language-from-file() {
    local filepath="${1:-}"
    local content="${2:-}"

    if [[ -n "${filepath}" ]]; then
        case "${filepath,,}" in
            *.py)     echo "python"; return ;;
            *.js)     echo "javascript"; return ;;
            *.ts)     echo "typescript"; return ;;
            *.sh | *.bash)  echo "bash"; return ;;
            *.rb)     echo "ruby"; return ;;
            *.go)     echo "go"; return ;;
            *.rs)     echo "rust"; return ;;
            *.java)   echo "java"; return ;;
            *.c)      echo "c"; return ;;
            *.cpp | *.cc | *.cxx)  echo "cpp"; return ;;
            *.h | *.hpp)  echo "cpp"; return ;;
            *.cs)     echo "csharp"; return ;;
            *.php)    echo "php"; return ;;
            *.sql)    echo "sql"; return ;;
            *.json)   echo "json"; return ;;
            *.xml)    echo "xml"; return ;;
            *.yaml | *.yml)  echo "yaml"; return ;;
            *.html | *.htm)  echo "html"; return ;;
            *.css)    echo "css"; return ;;
            *.md | *.markdown)  echo "markdown"; return ;;
            *.pl)     echo "perl"; return ;;
            *.lua)    echo "lua"; return ;;
            *.r)      echo "r"; return ;;
            *.swift)  echo "swift"; return ;;
            *.kt | *.kts)  echo "kotlin"; return ;;
            *.scala)  echo "scala"; return ;;
            *.hs)     echo "haskell"; return ;;
            *.ex | *.exs)  echo "elixir"; return ;;
            *.erl)    echo "erlang"; return ;;
            *.clj)    echo "clojure"; return ;;
            *.vim)    echo "vim"; return ;;
            *.dockerfile | Dockerfile*)  echo "docker"; return ;;
            Makefile* | *.mk)  echo "make"; return ;;
            *.tf)     echo "terraform"; return ;;
            *.ps1)    echo "powershell"; return ;;
        esac
    fi

    if [[ -n "${content}" ]]; then
        local first_line
        first_line=$(echo "${content}" | head -1)
        if [[ "${first_line}" == "#!"* ]]; then
            case "${first_line}" in
                *python*)  echo "python"; return ;;
                *bash*)    echo "bash"; return ;;
                *sh)       echo "bash"; return ;;
                *node*)    echo "javascript"; return ;;
                *ruby*)    echo "ruby"; return ;;
                *perl*)    echo "perl"; return ;;
                *php*)     echo "php"; return ;;
            esac
        fi
    fi

    echo ""
}

function extract-html-fragment() {
    :  'Extract content from HTML clipboard format
        Removes Version/StartHTML/EndHTML headers and fragment markers
        @stdin - HTML content (possibly with clipboard headers)
        @stdout - cleaned HTML content
    '
    local html
    html=$(cat)

    if [[ "${html}" == "Version:"* ]]; then
        echo "${html}" | \
            sed -n '/<!--StartFragment-->/,/<!--EndFragment-->/p' | \
            sed 's/<!--StartFragment-->//;s/<!--EndFragment-->//'
    else
        echo "${html}"
    fi
}

function code-to-html() {
    :  'Convert code to syntax-highlighted HTML
        @arg $1 - language (optional, auto-detect if empty)
        @stdin - code content
        @stdout - HTML with syntax highlighting
    '
    local lang="${1:-}"
    local code
    code=$(cat)

    # Validate input
    if [[ -z "${code}" ]]; then
        echo "error: no code content to highlight" >&2
        return ${E_ERROR}
    fi

    require-pygmentize || return ${?}

    local pygmentize_args=(-f html -O "noclasses,nowrap")

    if [[ -n "${lang}" ]]; then
        pygmentize_args+=(-l "${lang}")
    else
        pygmentize_args+=(-g)
    fi

    local highlighted
    highlighted=$(echo "${code}" | pygmentize "${pygmentize_args[@]}")
    # Replace newlines with <br> tags for Teams/Word compatibility
    highlighted=$(printf '%s' "${highlighted}" | awk '{if(NR>1)printf "<br>"; printf "%s", $0}')
    # Wrap in pre>code like Teams does
    printf '<pre style="font-family: Consolas, Monaco, '\''Courier New'\'', monospace; font-size: 14px; background-color: #f6f8fa; padding: 16px; border-radius: 6px; overflow: auto;"><code>%s</code></pre>' "${highlighted}"
}

function markdown-to-html() {
    :  'Convert markdown to HTML using pandoc
        @stdin - markdown content
        @stdout - HTML content
    '
    require-pandoc || return ${?}
    pandoc -f markdown -t html
}

function html-to-markdown() {
    :  'Convert HTML to markdown using pandoc
        @stdin - HTML content (possibly with clipboard headers)
        @stdout - markdown content
    '
    require-pandoc || return ${?}

    extract-html-fragment | pandoc -f html -t markdown --wrap=none | sed 's/<\/*body>//g'
}

function csv-to-html() {
    :  'Convert CSV to HTML table
        @stdin - CSV content
        @stdout - HTML table
    '
    local csv
    csv=$(cat)

    # Validate input
    if [[ -z "${csv}" ]]; then
        echo "error: no CSV content to convert" >&2
        return ${E_ERROR}
    fi

    echo "${csv}" | awk '
    BEGIN {
        FS=","
        print "<table border=\"1\" cellpadding=\"4\" cellspacing=\"0\" style=\"border-collapse:collapse\">"
    }
    NR==1 {
        print "<tr>"
        for(i=1; i<=NF; i++) {
            gsub(/^[ \t]+|[ \t]+$/, "", $i)
            print "<th>" $i "</th>"
        }
        print "</tr>"
        next
    }
    {
        print "<tr>"
        for(i=1; i<=NF; i++) {
            gsub(/^[ \t]+|[ \t]+$/, "", $i)
            print "<td>" $i "</td>"
        }
        print "</tr>"
    }
    END {
        print "</table>"
    }'
}

function set-clipboard-html() {
    :  'Set clipboard with HTML content (both HTML and plain text formats)
        @arg $1 - HTML content
        @arg $2 - plain text content (optional, derived from HTML if not provided)
    '
    local html_content="$1"
    local text_content="${2:-}"

    if [[ -z "${text_content}" ]]; then
        text_content=$(echo "${html_content}" | sed "s/<br>/\n/g" | sed "s/<[^>]*>//g" | sed 's/&quot;/"/g; s/&amp;/\&/g; s/&lt;/</g; s/&gt;/>/g; s/&nbsp;/ /g')
    fi

    local ps_html="${html_content//\'/\'\'}"
    local ps_text="${text_content//\'/\'\'}"

    powershell.exe -command "
Add-Type -AssemblyName System.Windows.Forms
\$html = @'
Version:0.9
StartHTML:00000097
EndHTML:ENDHTML_P
StartFragment:00000131
EndFragment:ENDFRAG_P
<html><body>
<!--StartFragment-->${ps_html}<!--EndFragment-->
</body></html>
'@
\$endFrag = \$html.IndexOf('<!--EndFragment-->')
\$endHtml = \$html.Length
\$html = \$html -replace 'ENDHTML_P', \$endHtml.ToString('D8')
\$html = \$html -replace 'ENDFRAG_P', \$endFrag.ToString('D8')
\$dataObj = New-Object System.Windows.Forms.DataObject
\$dataObj.SetData([System.Windows.Forms.DataFormats]::Html, \$html)
\$dataObj.SetData([System.Windows.Forms.DataFormats]::Text, '${ps_text}')
[System.Windows.Forms.Clipboard]::SetDataObject(\$dataObj, \$true)
"
}

function set-clipboard-csv() {
    :  'Set clipboard with CSV content (both CSV and plain text formats)
        @arg $1 - CSV content
    '
    local csv_content="$1"
    local ps_csv="${csv_content//\'/\'\'}"

    powershell.exe -command "
Add-Type -AssemblyName System.Windows.Forms
\$dataObj = New-Object System.Windows.Forms.DataObject
\$dataObj.SetData([System.Windows.Forms.DataFormats]::CommaSeparatedValue, '${ps_csv}')
\$dataObj.SetData([System.Windows.Forms.DataFormats]::Text, '${ps_csv}')
[System.Windows.Forms.Clipboard]::SetDataObject(\$dataObj, \$true)
"
}

function process-input-format() {
    :  'Process input content based on format settings
        @sets COPY_CONTENTS - processed content ready for clipboard
        @sets COPY_AS_HTML - true if content should be copied as rich text
        @sets COPY_AS_CSV - true if content should be copied as CSV format
    '
    COPY_AS_HTML=false
    COPY_AS_CSV=false

    local format="${INPUT_FORMAT}"
    if [[ -z "${format}" ]]; then
        if [[ -n "${FILEPATH}" ]]; then
            format="auto"
        else
            format="text"
        fi
    fi

    # Check for binary files when using a file
    if [[ -n "${FILEPATH}" ]]; then
        local mime_type
        mime_type=$(is-binary-file "${FILEPATH}")
        if [[ $? -eq 0 ]]; then
            echo "error: cannot copy binary file '${FILEPATH}' to clipboard (detected: ${mime_type})" >&2
            return ${E_BINARY_FILE}
        fi
    fi

    # Handle highlighting (takes precedence over format for code files)
    if ${DO_HIGHLIGHT}; then
        local lang="${HIGHLIGHT_LANG}"
        if [[ -z "${lang}" ]]; then
            lang=$(detect-language-from-file "${FILEPATH}" "${COPY_CONTENTS}")
        fi
        COPY_CONTENTS=$(echo "${COPY_CONTENTS}" | code-to-html "${lang}") || return ${?}
        COPY_AS_HTML=true
        return ${E_SUCCESS}
    fi

    # Auto-detect format from file extension
    if [[ "${format}" == "auto" && -n "${FILEPATH}" ]]; then
        format=$(detect-format-from-extension "${FILEPATH}")
    fi

    # Process based on format
    case "${format}" in
        text)
            ;;
        html)
            COPY_AS_HTML=true
            ;;
        markdown | md)
            COPY_CONTENTS=$(echo "${COPY_CONTENTS}" | markdown-to-html) || return ${?}
            COPY_AS_HTML=true
            ;;
        csv)
            # Keep original CSV for clipboard CSV format, but also create HTML version
            COPY_AS_CSV=true
            ;;
        *)
            echo "error: unknown format: ${format}" >&2
            return ${E_ERROR}
            ;;
    esac

    return ${E_SUCCESS}
}


## main ########################################################################
################################################################################

function main() {
    parse-args "${@}" || return ${?}

    debug-vars DO_COLOR FILEPATH DO_APPEND DO_HIGHLIGHT HIGHLIGHT_LANG \
               COPY_CONTENTS COPY_SOURCE IO INPUT_FORMAT OUTPUT_FORMAT

    local cmd_args=()

    if [[ "${IO}" == "copy" ]]; then
        process-input-format || return ${?}

        if ${COPY_AS_HTML}; then
            if ${DO_APPEND}; then
                echo "warning: --append is not supported with HTML format, replacing clipboard" >&2
            fi
            set-clipboard-html "${COPY_CONTENTS}"
        elif ${COPY_AS_CSV}; then
            if ${DO_APPEND}; then
                echo "warning: --append is not supported with CSV format, replacing clipboard" >&2
            fi
            set-clipboard-csv "${COPY_CONTENTS}"
        else
            ${DO_APPEND} && cmd_args+=( --append )
            [[ -n "${COPY_CONTENTS}" ]] && cmd_args+=( "${COPY_CONTENTS}" )
            set-clipboard "${cmd_args[@]}"
        fi
    elif [[ "${IO}" == "paste" ]]; then
        if [[ "${OUTPUT_FORMAT}" == "md" ]]; then
            get-clipboard --html | html-to-markdown
        else
            get-clipboard "--${OUTPUT_FORMAT}"
        fi
    fi
}


## run #########################################################################
################################################################################

[[ "${BASH_SOURCE[0]}" == "${0}" ]] && main "${@}"
