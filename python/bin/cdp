#!/usr/bin/env python3
"""
CDP - Chrome DevTools Protocol CLI

A simple CLI for interacting with browsers via Chrome DevTools Protocol.
"""
from __future__ import annotations

import sys
from pathlib import Path

# =============================================================================
# Constants
# =============================================================================

DEPENDENCIES = ["typer", "websockets"]
DEFAULT_PORT = 9222
DEFAULT_HOST = "localhost"
TIMEOUT_SECONDS = 10
CONFIG_PATHS = [
    Path.home() / ".config" / "cdp" / "config.json",
    Path.home() / ".cdprc.json",
]

# =============================================================================
# Dependency Management
# =============================================================================

if "--install-dependencies" in sys.argv:
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", *DEPENDENCIES])
    print("Dependencies installed successfully!")
    sys.exit(0)

try:
    import typer
    import websockets.sync.client as ws_client
except ImportError as e:
    print(f"Missing dependency: {e.name}")
    print("Re-run with the `--install-dependencies` option to setup")
    sys.exit(1)

import asyncio
import base64
import json
import re
import urllib.request
from typing import Optional

# =============================================================================
# App Setup
# =============================================================================

app = typer.Typer(
    help="Chrome DevTools Protocol CLI for browser automation.",
    no_args_is_help=True,
)

# Global state for port/host (set via callback)
_config: dict[str, any] = {
    "host": DEFAULT_HOST,
    "port": DEFAULT_PORT,
    "json_output": False,
    "headers": {},
}


def load_config() -> dict:
    """Load config from file if it exists."""
    for path in CONFIG_PATHS:
        if path.exists():
            try:
                with open(path) as f:
                    return json.load(f)
            except (json.JSONDecodeError, OSError) as e:
                print(f"Warning: Failed to load config from {path}: {e}", file=sys.stderr)
    return {}


def parse_header(header: str) -> tuple[str, str]:
    """Parse a curl-style header string into (name, value)."""
    if ":" not in header:
        raise typer.BadParameter(f"Invalid header format: {header!r} (expected 'Name: value')")
    name, _, value = header.partition(":")
    return name.strip(), value.strip()


@app.callback()
def main(
    port: Optional[int] = typer.Option(None, "--port", "-p", help="CDP port"),
    host: Optional[str] = typer.Option(None, "--host", help="CDP host"),
    json_output: bool = typer.Option(False, "--json", "-j", help="Output as JSON"),
    headers: list[str] = typer.Option([], "--header", "-H", help="HTTP header (curl-style, e.g. 'Host: localhost')"),
):
    """Configure CDP connection settings."""
    file_config = load_config()

    # CLI args override config file, which overrides defaults
    _config["host"] = host or file_config.get("host", DEFAULT_HOST)
    _config["port"] = port or file_config.get("port", DEFAULT_PORT)
    _config["json_output"] = json_output or file_config.get("json", False)

    # Merge headers: config file first, then CLI (CLI wins on conflicts)
    file_headers = {}
    for h in file_config.get("headers", []):
        name, value = parse_header(h)
        file_headers[name] = value
    cli_headers = dict(parse_header(h) for h in headers)
    _config["headers"] = {**file_headers, **cli_headers}


# =============================================================================
# CDP Helpers
# =============================================================================


def cdp_request(
    path: str,
    method: str = "GET",
    extra_headers: dict[str, str] | None = None,
    data: str | bytes | None = None,
) -> dict | list | str:
    """Make an HTTP request to the CDP endpoint with configured headers."""
    url = f"http://{_config['host']}:{_config['port']}{path}"

    # Encode data if provided as string
    if isinstance(data, str):
        data = data.encode("utf-8")

    request = urllib.request.Request(url, method=method, data=data)

    # Add configured headers
    for name, value in _config["headers"].items():
        request.add_header(name, value)

    # Add extra headers (override configured if conflict)
    if extra_headers:
        for name, value in extra_headers.items():
            request.add_header(name, value)

    try:
        with urllib.request.urlopen(request, timeout=TIMEOUT_SECONDS) as resp:
            content = resp.read().decode("utf-8")
            try:
                return json.loads(content)
            except json.JSONDecodeError:
                return content
    except Exception as e:
        print(f"Error connecting to CDP at {url}: {e}", file=sys.stderr)
        sys.exit(1)


def get_tabs(include_all: bool = False) -> list[dict]:
    """Fetch list of open tabs from CDP.

    By default, filters out workers, extensions, and empty entries.
    Pass include_all=True to get everything.
    """
    tabs = cdp_request("/json/list")
    if include_all:
        return tabs
    return [
        t for t in tabs
        if t.get("type") in ("page", "other")
        and t.get("url")
        and not t.get("url", "").startswith("chrome-extension://")
    ]


def resolve_tab(selector: str) -> dict:
    """
    Resolve a tab selector to a tab dict.

    Selector can be:
    - Index (0, 1, 2...)
    - Tab ID (hex string)
    - Title substring (case-insensitive match)
    """
    tabs = get_tabs()  # Uses filtered list by default

    if not tabs:
        print("No tabs found", file=sys.stderr)
        sys.exit(1)

    # Try as index
    if selector.isdigit():
        idx = int(selector)
        if 0 <= idx < len(tabs):
            return tabs[idx]
        print(f"Tab index {idx} out of range (0-{len(tabs)-1})", file=sys.stderr)
        sys.exit(1)

    # Try as tab ID
    for tab in tabs:
        if tab.get("id") == selector:
            return tab

    # Try as title substring (case-insensitive)
    selector_lower = selector.lower()
    matches = [t for t in tabs if selector_lower in t.get("title", "").lower()]

    if len(matches) == 1:
        return matches[0]
    elif len(matches) > 1:
        print(f"Ambiguous selector '{selector}' matches {len(matches)} tabs:", file=sys.stderr)
        for m in matches:
            print(f"  - {m.get('title', 'Untitled')}", file=sys.stderr)
        sys.exit(1)

    print(f"No tab found matching '{selector}'", file=sys.stderr)
    sys.exit(1)


def fix_ws_url(ws_url: str) -> str:
    """Fix WebSocket URL to use configured host and ensure port is present."""
    # CDP often returns ws://localhost/... without port - add it
    if "ws://localhost/" in ws_url:
        ws_url = ws_url.replace("ws://localhost/", f"ws://localhost:{_config['port']}/")
    # Replace host if using custom host
    if _config["host"] != "localhost":
        ws_url = ws_url.replace("ws://localhost:", f"ws://{_config['host']}:")
    return ws_url


def get_browser_ws_url() -> str:
    """Get the browser-level WebSocket debugger URL."""
    version_info = cdp_request("/json/version")
    ws_url = version_info.get("webSocketDebuggerUrl", "")
    if not ws_url:
        print("No browser WebSocket URL found", file=sys.stderr)
        sys.exit(1)
    return fix_ws_url(ws_url)


def get_tab_ws_url(selector: str) -> str:
    """Resolve a tab and return its fixed WebSocket URL."""
    resolved = resolve_tab(selector)
    ws_url = resolved.get("webSocketDebuggerUrl")
    if not ws_url:
        print("No WebSocket URL for this tab", file=sys.stderr)
        sys.exit(1)
    return fix_ws_url(ws_url)


def send_cdp_command(ws_url: str, method: str, params: dict | None = None) -> dict:
    """Send a CDP command via WebSocket and return the result."""
    return send_ws_command(ws_url, method, params)


class CDPError(Exception):
    """Exception raised for CDP protocol errors."""
    pass


def send_ws_command(ws_url: str, method: str, params: dict | None = None, raise_on_error: bool = False) -> dict:
    """Send a command via WebSocket and return the result."""
    msg = {"id": 1, "method": method, "params": params or {}}

    try:
        with ws_client.connect(ws_url, close_timeout=TIMEOUT_SECONDS) as websocket:
            websocket.send(json.dumps(msg))

            while True:
                response = json.loads(websocket.recv())
                if response.get("id") == 1:
                    if "error" in response:
                        if raise_on_error:
                            raise CDPError(response["error"])
                        print(f"CDP error: {response['error']}", file=sys.stderr)
                        sys.exit(1)
                    return response.get("result", {})
    except CDPError:
        raise
    except Exception as e:
        if raise_on_error:
            raise CDPError(str(e))
        print(f"WebSocket error: {e}", file=sys.stderr)
        sys.exit(1)


def send_browser_command(method: str, params: dict | None = None, raise_on_error: bool = False) -> dict:
    """Send a command to the browser-level WebSocket endpoint."""
    ws_url = get_browser_ws_url()
    return send_ws_command(ws_url, method, params, raise_on_error=raise_on_error)


def output(data: any, plain_formatter: callable = None):
    """Output data as JSON or plain text based on config."""
    if _config["json_output"]:
        print(json.dumps(data, indent=2))
    elif plain_formatter:
        plain_formatter(data)
    else:
        print(data)


# =============================================================================
# Commands
# =============================================================================


@app.command()
def tabs(
    all_targets: bool = typer.Option(False, "-a", "--all", help="Show all targets including workers/extensions"),
):
    """List all open browser tabs."""
    tab_list = get_tabs(include_all=all_targets)

    def fmt(tabs):
        for i, tab in enumerate(tabs):
            title = tab.get("title", "Untitled")[:60]
            url = tab.get("url", "")[:80]
            print(f"{i}: {title}")
            print(f"   {url}")

    output(tab_list, fmt)


@app.command()
def url(tab: str = typer.Argument("0", help="Tab selector (index, ID, or title substring)")):
    """Get the URL of a tab."""
    resolved = resolve_tab(tab)
    output(resolved.get("url", ""), print)


@app.command()
def title(tab: str = typer.Argument("0", help="Tab selector (index, ID, or title substring)")):
    """Get the title of a tab."""
    resolved = resolve_tab(tab)
    output(resolved.get("title", ""), print)


@app.command()
def dom(tab: str = typer.Argument("0", help="Tab selector (index, ID, or title substring)")):
    """Get the full HTML of a tab."""
    ws_url = get_tab_ws_url(tab)
    result = send_cdp_command(ws_url, "Runtime.evaluate", {
        "expression": "document.documentElement.outerHTML",
        "returnByValue": True,
    })

    html = result.get("result", {}).get("value", "")
    output(html, print)


@app.command()
def text(tab: str = typer.Argument("0", help="Tab selector (index, ID, or title substring)")):
    """Get the text content of a tab."""
    ws_url = get_tab_ws_url(tab)
    result = send_cdp_command(ws_url, "Runtime.evaluate", {
        "expression": "document.body.innerText",
        "returnByValue": True,
    })

    text_content = result.get("result", {}).get("value", "")
    output(text_content, print)


@app.command()
def screenshot(
    tab: str = typer.Argument("0", help="Tab selector (index, ID, or title substring)"),
    output_path: Optional[Path] = typer.Argument(None, help="Output file path (default: stdout as base64)"),
    format: str = typer.Option("png", "--format", "-f", help="Image format: png or jpeg"),
):
    """Take a screenshot of a tab."""
    ws_url = get_tab_ws_url(tab)
    result = send_cdp_command(ws_url, "Page.captureScreenshot", {"format": format})

    img_data = result.get("data", "")

    if output_path:
        output_path.write_bytes(base64.b64decode(img_data))
        print(f"Screenshot saved to {output_path}")
    else:
        print(img_data)


@app.command("eval")
def evaluate(
    tab: str = typer.Argument(..., help="Tab selector (index, ID, or title substring)"),
    expression: str = typer.Argument(..., help="JavaScript expression to evaluate"),
    await_promise: bool = typer.Option(False, "--await", "-a", help="Await promise result"),
):
    """Execute JavaScript in a tab and return the result."""
    ws_url = get_tab_ws_url(tab)
    params = {
        "expression": expression,
        "returnByValue": True,
    }
    if await_promise:
        params["awaitPromise"] = True

    result = send_cdp_command(ws_url, "Runtime.evaluate", params)
    value = result.get("result", {}).get("value", result.get("result", {}))

    # Always output as JSON for consistency
    if isinstance(value, (dict, list)):
        print(json.dumps(value, indent=2))
    else:
        print(value)


@app.command()
def navigate(
    tab: str = typer.Argument(..., help="Tab selector (index, ID, or title substring)"),
    target_url: str = typer.Argument(..., help="URL to navigate to"),
):
    """Navigate a tab to a URL."""
    ws_url = get_tab_ws_url(tab)
    result = send_cdp_command(ws_url, "Page.navigate", {"url": target_url})

    if _config["json_output"]:
        print(json.dumps(result, indent=2))
    else:
        print(f"Navigated to {target_url}")


@app.command()
def info():
    """Show browser version and connection info."""
    data = cdp_request("/json/version")

    def fmt(d):
        print(f"Browser: {d.get('Browser', 'Unknown')}")
        print(f"Protocol: {d.get('Protocol-Version', 'Unknown')}")
        print(f"V8: {d.get('V8-Version', 'Unknown')}")

    output(data, fmt)


@app.command()
def raw(
    path: str = typer.Argument(..., help="URL path (e.g., /json/list)"),
    method: str = typer.Option("GET", "-X", "--method", help="HTTP method"),
    headers: list[str] = typer.Option([], "-H", "--header", help="Extra header (curl-style)"),
    data: Optional[str] = typer.Option(None, "-d", "--data", help="Request body data"),
):
    """Make a raw HTTP request to the CDP endpoint."""
    extra_headers = dict(parse_header(h) for h in headers) if headers else None

    result = cdp_request(path, method=method, extra_headers=extra_headers, data=data)

    if isinstance(result, str):
        print(result)
    elif _config["json_output"]:
        print(json.dumps(result, indent=2))
    else:
        print(json.dumps(result, indent=2))


@app.command()
def ws(
    method: str = typer.Argument(..., help="CDP method (e.g., Target.getTargets)"),
    params: Optional[str] = typer.Option(None, "-p", "--params", help="JSON params"),
    tab: Optional[str] = typer.Option(None, "-t", "--tab", help="Tab selector (uses tab's WebSocket; omit for browser-level)"),
):
    """Send a raw WebSocket command to the CDP endpoint."""
    parsed_params = json.loads(params) if params else None

    if tab:
        ws_url = get_tab_ws_url(tab)
        result = send_ws_command(ws_url, method, parsed_params)
    else:
        result = send_browser_command(method, parsed_params)

    print(json.dumps(result, indent=2))


@app.command()
def windows():
    """List browser windows with their tabs."""
    # Get all targets
    targets = send_browser_command("Target.getTargets")
    target_infos = targets.get("targetInfos", [])

    # Filter to pages and "other" (like newtab)
    pages = [t for t in target_infos if t.get("type") in ("page", "other")]

    # Get window info for each page
    windows_map: dict[int, list[dict]] = {}
    for page in pages:
        target_id = page.get("targetId")
        try:
            window_info = send_browser_command(
                "Browser.getWindowForTarget",
                {"targetId": target_id},
                raise_on_error=True
            )
            window_id = window_info.get("windowId", 0)
        except CDPError:
            # Some targets may not have windows (e.g., edge:// pages)
            window_id = 0

        if window_id not in windows_map:
            windows_map[window_id] = []
        windows_map[window_id].append(page)

    # Output
    def fmt(data):
        for window_id, tabs in data.items():
            print(f"Window {window_id}:")
            for tab in tabs:
                title = tab.get("title", "Untitled")[:55]
                url = tab.get("url", "")[:75]
                print(f"  - {title}")
                print(f"    {url}")
            print()

    if _config["json_output"]:
        print(json.dumps(windows_map, indent=2))
    else:
        fmt(windows_map)


# =============================================================================
# Entry Point
# =============================================================================

if __name__ == "__main__":
    app()
