#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
This module contains code for generating code that performs a given task. It uses the
OpenAI API to generate code that performs the task and then runs the code to check
the output against the expected result. If the output is incorrect, it generates new
code and runs it again until the output is correct.

TODO:
- Convert the Language enum into a class that can be extended to support more
  languages.
- Add support for generating code that involves multiple scripts.
- Create a class specifically for a single task. Among other things, track the
  version history. The class should roughly look like this:
  class CodeTask:
    history: list[CodeTask]
    version: Version
    code: str
    task: str
    language: Language
    expected_output: CodeOutput
    outline: list[str]  # to be generated by OpenAI if not provided
    __init__(self, api_key: str, task: str, language: Language,
             expected_stdout: str = None, expected_stderr: str = None,
             outline: list[str] = None) -> None
    run(self) -> CodeOutput
    update(self, prompt: str, engine: str, **kwargs) -> str
    edit(self, prompt: str, engine: str, **kwargs) -> str
    generate(self, prompt: str, engine: str, **kwargs) -> str
    test(self, code: Path | str) -> bool
- Create relevant classes for the above.
- Update CodeGenerator to use the new CodeTask class.
"""

from __future__ import annotations

import openai as _openai
import requests as _requests
import subprocess as _subprocess
import tempfile as _tempfile
import time as _time

from enum import Enum as _Enum
from pathlib import Path as _Path
from textwrap import dedent as _dedent


class Language(_Enum):
    """
    An enumeration of supported programming languages and their extensions.
    """

    PYTHON = "py"
    JAVASCRIPT = "js"
    JAVA = "java"
    C = "c"
    BASH = "sh"

    @staticmethod
    def find(key: str) -> Language:
        """
        Search for a language which matches the given key and return the language.
        """
        key = key.lower()
        for language in Language:
            if key in language.name.lower() or key in language.value.lower():
                return language
        raise ValueError(f"Invalid language: {key}")

    def get_extension(self) -> str:
        """
        Return the file extension for the given language.
        """
        return self.value

    def get_run_command(self) -> list[str]:
        """
        Return the command(s) used to run a script in the given language. Commands are
        returned as a list of strings, where each string is a command to be run. Each
        command is run in order, and each subsequent command is only run if each
        preceding command exited successfully. Commands may contain several default
        values:
        - "{path}" is replaced with the path to the script.
        - "{name}" is replaced with the name of the script (without the extension)
        - "{interpreter}" is replaced with the path to the default interpreter for the
            given language.
        - "{ext}" is replaced with the file extension for the given language.
        """
        if self == Language.PYTHON:
            return ["python {path}"]
        elif self == Language.JAVA:
            return [
                "javac {path}",
                "java {name}",
            ]
        elif self == Language.JAVASCRIPT:
            return ["node {path}"]
        elif self == Language.BASH:
            return ["bash {path}"]
        elif self == Language.C:
            return [
                "gcc {path} -o {name}",
                "./{name}",
            ]
        else:
            raise ValueError(f"Invalid language: {self}")


class CodeGenerator:
    class RequestMode(_Enum):
        """
        An enumeration of the different modes that the code generator can run in.
        """

        EDIT = "edits"
        COMPLETION = "completions"

        # TODO: the below was auto-generated. I'm leaving it in for now because it
        # TODO: looks like an awesome idea and I want to implement it later.
        # # Generate code that runs a single script and returns the result
        # SINGLE = "single"
        # # Generate code that runs multiple scripts and returns the result of the last
        # # script
        # MULTIPLE = "multiple"
        # Edit the code to fix any errors

    def __init__(self, api_key: str, default_language: Language = Language.PYTHON):
        # Set up an OpenAI client and test the API key
        self.openai_client = _openai.api_requestor.APIRequestor(api_key)
        self._test_auth()

    def _test_auth(self):
        """
        Test the OpenAI API key by sending a request to the OpenAI API. If the request
        fails, an exception is raised.
        """
        # Test the OpenAI API key by sending a request to the OpenAI API
        # We want to send a request that uses the API key, but doesn't require any
        # special permissions and requires the least amount of data/tokens. The
        # "Search" endpoint is a good candidate for this, so we'll use that.
        try:
            self.openai_client.request(url="/completions", method="GET")
        except _openai.error.AuthenticationError:
            raise ValueError("Invalid OpenAI API key")
        except _openai.error.InvalidRequestError:
            pass

    def _send_request(
        self,
        prompt: str = None,
        engine: str = "davinci",
        mode: CodeGenerator.RequestMode | str = "completion",
        temperature: float = 0,
        **kwargs,
    ) -> str:
        """
        Send a request to the OpenAI API and return the response.

        Args:
            prompt (str): The prompt to send to the OpenAI API.
            engine (str, optional): The engine to use. Defaults to "davinci".
            mode (CodeGenerator.RequestMode | str): The mode to use. This should be a
                valid value from the RequestModes enumeration or a string containing the
                name of a valid mode. Defaults to "completions".
            temperature (float, optional): A value between 0-1 which determines how
                random the generated code is. Higher values result in more random code;
                lower values result in more predictable code. Defaults to 0.5.
            **kwargs: Additional keyword arguments to pass to the OpenAI API.

        Returns:
            str: The generated code.
        """
        # Get / verify the mode
        if isinstance(mode, CodeGenerator.RequestMode):
            mode = mode.value
        elif isinstance(mode, str):
            try:
                mode = CodeGenerator.RequestMode[mode.upper()].value
            except KeyError:
                raise ValueError(f"Invalid request mode: {mode}")

        # Fill in the default values for the keyword arguments
        params: dict[str, str | int | float] = {
            "model": engine,
            "prompt": prompt,
            "max_tokens": 500,
            "temperature": temperature,
            "top_p": 1,
            "frequency_penalty": 0,
            "presence_penalty": 0,
            "logprobs": 0,
            "best_of": 1,
        }
        params.update(kwargs)
        # Remove any keys with a value of None
        params = {k: v for k, v in params.items() if v is not None}

        # Send a request to the OpenAI API and return the generated code
        response = self.openai_client.request("post", f"/{mode}", params)
        # print("RAW RESPONSE:", response[0].data)
        return response[0].data["choices"][0]["text"]

    def _run_code(
        self,
        language: Language,
        code: str = None,
        script_path: str | _Path = None,
        run: str = None,
    ) -> tuple[str, str]:
        """
        Run the given script, capturing its stdout and stderr. By default, the script
        is run using the appropriate interpreter for the given language. If the run
        argument is given, it is used to run the script instead.

        Args:
            language (Language): The language of the script.
            script_path (str | _Path): The path to the script to run. If this is not
                given, a temporary file is created and the script is written to it.
                Defaults to None.
            run (str, optional): The command to use to run the script. The string used
                may contains several default values:
                - "{path}" is replaced with the path to the script.
                - "{name}" is replaced with the name of the script (without the
                  extension)
                - "{interpreter}" is replaced with the path to the default interpreter
                  for the given language.
                - "{ext}" is replaced with the file extension for the given language.
        """
        # Ensure that either the code or the script path is given
        if code is None and script_path is None:
            raise ValueError("Either code or script_path must be specified")

        # Ensure that the script path is given and is a Path object
        if script_path is None:
            script_path = _Path(_tempfile.mkstemp()[1])
            # _time.strftime("codegen_%Y%m%d-%H%M%S") + language.get_extension()
        else:
            script_path = _Path(script_path)
        if code is not None:
            script_path.write_text(code)
        script_name = script_path.stem
        script_ext = script_path.suffix
        # interpreter = language.get_interpreter()
        if run is None:
            run = language.get_run_command()
        stdout: str = None
        stderr: str = None
        for command in run:
            command = command.format(
                path=script_path,
                name=script_name,
                # interpreter=interpreter,
                ext=script_ext,
            )
            process = _subprocess.Popen(
                command,
                shell=True,
                stdout=_subprocess.PIPE,
                stderr=_subprocess.PIPE,
                universal_newlines=True,
            )
            _stdout, _stderr = process.communicate()

            # Append the output to the stdout and stderr variables
            if stdout is None:
                # If the stdout variable is None, set it to the output of the command.
                # This allows us to return None if the command didn't produce any
                # output instead of returning an empty string.
                stdout = _stdout
            else:
                stdout += _stdout

            # Do the same thing for stderr
            if stderr is None:
                stderr = _stderr
            else:
                stderr += _stderr

            # If the command failed, stop running the script
            if process.returncode != 0:
                break
        return stdout, stderr

    def _check_output(
        self, code: str, language: str, task: str, stdout: str, stderr: str
    ) -> tuple[bool, str]:
        # Check the output of the script against the expected result
        prompt = _dedent(
            f"""
            If the input code, its STDOUT, and its STDERR appear to match the specified
            task, reply with "yes". Otherwise, reply with an explanation of how to fix
            the code.

            LANGUAGE: {language.name.lower()}
            TASK: """
        ).strip()
        prompt += task
        if stdout:
            prompt += "\nSTDOUT: " + stdout
        if stderr:
            prompt += "\nSTDERR: " + stderr
        prompt += _dedent(
            f"""
            CODE BELOW THIS LINE
            --------------------
        """
        )
        prompt += code
        prompt += _dedent(
            f"""
            --------------------
            CODE ABOVE THIS LINE

            ANALYSIS: """
        )
        # print("<CODE CHECK PROMPT>\n", prompt, "\n</CODE CHECK PROMPT>")
        # print("<CODE CHECK RESPONSE>")
        response = self._send_request(prompt=prompt, engine="text-davinci-003")
        # print("</CODE CHECK RESPONSE>")
        edits: str = response.strip()
        return edits.lower().startswith("yes"), edits

    def generate_code(
        self,
        task: str,
        language: Language | str = Language.PYTHON,
        filepath: str | _Path = None,
        **kwargs,
    ):
        log = open("log.txt", "a")

        # Ensure that the language is a Language object
        if isinstance(language, str):
            try:
                language = Language[language.upper()]
            except KeyError:
                raise ValueError(f"Invalid language: {language}")

        # Use the OpenAI API to generate code that performs the task using the OpenAI
        # Codex API
        engine: str = "code-davinci-002"
        prompt: str = _dedent(f"# Language: {language.name}\n# Task: {task}\n")
        log.write("<INITIAL PROMPT>\n" + prompt + "\n</INITIAL PROMPT>\n")
        log.flush()

        # Generate the code using the "insert" method
        params: dict[str, object] = {
            "prompt": prompt,
            "engine": engine,
            "frequency_penalty": 0,
            "presence_penalty": 0,
            "max_tokens": 600,
            "suffix": "\n",
            "temperature": 0,
            "top_p": 1,
        }
        params.update(kwargs)
        code: str = self._send_request(**params)
        log.write("<GENERATED CODE>\n" + code + "\n</GENERATED CODE>\n")
        log.flush()

        # Run the code
        stdout, stderr = self._run_code(language, code, filepath)
        log.write("<STDOUT>\n" + stdout + "\n</STDOUT>\n")
        log.write("<STDERR>\n" + stderr + "\n</STDERR>\n")
        log.flush()

        # Check the output of the code
        is_correct, suggestions = self._check_output(
            code, language, task, stdout, stderr
        )
        log.write("<IS CORRECT>\n" + str(is_correct) + "\n</IS CORRECT>\n")
        log.write("<SUGGESTIONS>\n" + suggestions + "\n</SUGGESTIONS>\n")
        log.flush()

        while not is_correct:
            # If the code is not correct, use the /edits endpoint to implement the
            # suggested changes
            instruction: str = _dedent(
                f"""
                Task: {task}
                Language: {language}
                Suggestions: """
            )
            instruction += f"{suggestions}\n\n"
            instruction += (
                "Please update the input code to match the above suggestions."
            )
            log.write("<INSTRUCTION>\n" + instruction + "\n</INSTRUCTION>\n")
            log.flush()
            code = self._send_request(
                engine="code-davinci-edit-001",
                input=code,
                instruction=instruction,
                mode="edit",
                max_tokens=None,
                frequency_penalty=None,
                presence_penalty=None,
                logprobs=None,
                best_of=None,
            )
            log.write("<UPDATED CODE>\n" + code + "\n</UPDATED CODE>\n")
            log.flush()

            # Run the code
            stdout, stderr = self._run_code(language, code, filepath)
            log.write("<UPDATED STDOUT>\n" + stdout + "\n</UPDATED STDOUT>\n")
            log.write("<UPDATED STDERR>\n" + stderr + "\n</UPDATED STDERR>\n")

            # Check the output of the code
            is_correct, suggestions = self._check_output(
                code, language, task, stdout, stderr
            )
            log.write(
                "<UPDATED IS CORRECT>\n" + str(is_correct) + "\n</UPDATED IS CORRECT>\n"
            )
            log.write(
                "<UPDATED SUGGESTIONS>\n" + suggestions + "\n</UPDATED SUGGESTIONS>\n"
            )
            log.flush()

        log.write("<FINAL CODE>\n" + code + "\n</FINAL CODE>\n")
        log.flush()
        log.close()
        return code


def generate_code(task):
    # Use the OpenAI API to generate code that performs the task
    code = None
    # TODO: Make a request to the OpenAI API to generate code
    return code


def write_code_to_file(code, language, output_file):
    # Write the code to a file
    with open(output_file, "w") as f:
        f.write(code)


def run_script(script_path, language):
    # Run the script and capture its stdout and stderr
    stdout = None
    stderr = None
    # TODO: Use subprocess to run the script and capture its output
    return stdout, stderr


def check_output(stdout, stderr, task):
    # Check the output against the expected result
    is_correct = None
    # TODO: Make a request to the OpenAI API to check the output
    return is_correct


def main():
    import argparse
    import os

    # Parse the command line arguments
    parser = argparse.ArgumentParser()
    parser.add_argument("task", nargs="+", default=None)
    parser.add_argument("--language", default="python")
    parser.add_argument(
        "--output-file", default=f"autocode-{_time.strftime('%Y%m%d_%H%M%S')}.py"
    )
    parser.add_argument("--max-tokens", type=int, default=500)
    parser.add_argument("--api-key", default=os.environ.get("OPENAI_API_KEY"))
    args = parser.parse_args()

    # Generate the code
    code_generator: CodeGenerator = CodeGenerator(args.api_key)
    code = code_generator.generate_code(
        task=" ".join(args.task),
        language=args.language,
        filepath=args.output_file,
        max_tokens=args.max_tokens,
    )
    print(code.strip())


if __name__ == "__main__":
    main()
